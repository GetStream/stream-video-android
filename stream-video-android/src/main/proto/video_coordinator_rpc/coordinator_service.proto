syntax = "proto3";

package stream.video;

import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";
import "validate/validate.proto";
import "video_models/models.proto";

option go_package = "github.com/GetStream/video/protobuf/video_coordinator_rpc";

service CallCoordinatorService {
  // CreateCall creates a new call that is unique for the combination of type and id fields
  // If a call with the same type and id already exists then the call will be updated based on the request (if allowed and if needed)
  // The user calling this endpoint will be created if necessary ({id: id})
  // The users listed in the participants field will also be created if necessary ({id: id})
  rpc CreateCall(CreateCallRequest) returns (CreateCallResponse);

  // GetCall retrieves the state for one call, the user calling this endpoint is created if missing
  rpc GetCall(GetCallRequest) returns (GetCallResponse);

  rpc UpdateCall(UpdateCallRequest) returns (UpdateCallResponse);
  rpc DeleteCall(DeleteCallRequest) returns (DeleteCallResponse);

  // JoinCall returns the call state and the list of edges that the user should be check for latency
  // this endpoint is meant to be used to prepare the information needed to call the SelectEdgeServer endpoint
  rpc JoinCall(JoinCallRequest) returns (JoinCallResponse);

  rpc SelectEdgeServer(SelectEdgeServerRequest) returns(SelectEdgeServerResponse);
  rpc LeaveCall(LeaveCallRequest) returns (LeaveCallResponse);
  rpc EndCall(EndCallRequest) returns (EndCallResponse);

  // AddDevice registers the mobile device for push notifications
  // this endpoint will create the user if missing
  // if a device with the same id and push_provider_name exists, then the operation will be ignored
  rpc AddDevice(AddDeviceRequest) returns (AddDeviceResponse);
  rpc RemoveDevice(RemoveDeviceRequest) returns (RemoveDeviceResponse);
  rpc ListDevices(ListDevicesRequest) returns (ListDevicesResponse);

  // add reaction should perhaps just be handled by chat
  rpc SendEvent(SendEventRequest) returns (SendEventResponse);

  rpc SendCustomEvent(SendCustomEventRequest) returns (SendCustomEventResponse);

  // room is a confusing name. better to call it breakout room
  // breakout rooms have their own audio/video track
  // breakout rooms have their own chat
  /**
  TODO
  rpc CreateBreakoutRoom(CreateBreakoutRoomRequest) returns (CreateBreakoutRoomResponse);
  rpc JoinBreakoutRoom() returns ();
  rpc LeaveBreakoutRoom() returns ();
  rpc DeleteBreakoutRoom() returns ();
  */

  // server side sync & advanced endpoints
  rpc CreateOrUpdateCalls(CreateOrUpdateCallsRequest) returns (CreateOrUpdateCallsResponse);
  rpc CreateOrUpdateUsers(CreateOrUpdateUsersRequest) returns (CreateOrUpdateUsersResponse);

  // recording a call or transcribing a call can be
  // A. Enabled by default for a call type
  // B. Enabled when creating the call per the default call type settings
  // C. Configured differently for that specific call
  // D. Enabled during the call
  rpc TranscribeCall(TranscribeCallRequest) returns (TranscribeCallResponse);
  rpc StopTranscribeCall(StopTranscribeCallRequest) returns (StopTranscribeCallResponse);

  // starts broadcast to HLS and/or RTMP, replaces existing settings if broadcasting is already started
  rpc StartBroadcast(StartBroadcastRequest) returns (StartBroadcastResponse);
  // stops broadcasting to HLS and/or RTMP
  rpc StopBroadcast(StopBroadcastRequest) returns (StopBroadcastResponse);

  rpc StartRecording(StartRecordingRequest) returns (StartRecordingResponse);
  rpc StopRecording(StopRecordingRequest) returns (StopRecordingResponse);
  rpc GetRecordings(GetRecordingsRequest) returns (GetRecordingsResponse);

  // User & GDPR endpoints, delete user
  // we need to review the API contract based on Chat
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);
  rpc ExportUser(ExportUserRequest) returns (ExportUserResponse);
  // This requires having some sort of user/team level concept

  // TODO: endpoints needed to build a good dashboard experience
  // - listing calls and filtering based on their attributes
  // - listing users and filtering based on their attributes

  // endpoint for storing stats (perhaps we should move this to the SFU layer though)
  rpc StoreCallStats(StoreCallStatsRequest) returns (StoreCallStatsResponse);
  rpc GetCallStats(GetCallStatsRequest) returns (GetCallStatsResponse);
  // endpoint for reviewing/rating the quality of calls
  rpc ReviewCall(ReviewCallRequest) returns (ReviewCallResponse);
  // endpoint for users to report issues with a call
  rpc ReportIssue(ReportIssueRequest) returns (ReportIssueResponse);



}

message GetCallRequest {
  string id = 1;
  string type = 2;
}

message GetCallResponse {
  Call call = 1;
  CallState call_state = 2;
}

message CreateOrUpdateCallsRequest {
  repeated CreateCallRequest calls = 1;
}

message CreateOrUpdateCallsResponse {
  repeated Call calls = 1;
}

message CreateCallRequest {
  // the call type
  string type = 1; // required

  // the call id, if not provided a unique value will be generated based on UUID v4
  string id = 2; // required

  // call custom data
  google.protobuf.Struct custom = 3;

  // the list of participant ids
  repeated string participant_ids = 4;

  // HLS broadcast, overrides the default call type setting if provided
  google.protobuf.BoolValue hls_broadcast = 6;

  // request video to be forwarded to a list of RTMP servers
  RTMPOptions rtmp = 7;

  // transcription, overrides the default call type setting if provided
  google.protobuf.BoolValue transcribe = 8;

  // the transcription options for this call, only relevant if transcribe is enabled
  TranscribeOptions transcribe_options = 9;

  // the recording option, overrides the default call type setting if provided
  google.protobuf.BoolValue recording = 10;

  // the ring option, overrides the default call type setting if provided
  google.protobuf.BoolValue notify = 11;
}

message CreateCallResponse {
  Call call = 1 [(validate.rules).message.required = true];
}

message UpdateCallRequest {
  string id = 1;
  string type = 2;
  bytes json_encoded_custom_data = 3;
  // TODO: additional options and overrides to default settings
}
message UpdateCallResponse {
  Call call = 1;
}

message DeleteCallRequest {
  string id = 1;
}
message DeleteCallResponse {
}

message SelectEdgeServerRequest {
  string call_type = 1;
  string call_id = 2;
  map<string, Latency> latency_by_edge = 3;
}

message SelectEdgeServerResponse {
  // the edge server hosting the video call
  EdgeServer edge_server = 1 [(validate.rules).message.required = true];

  // the auth token needed to authenticate to the edge server
  string token = 2 [(validate.rules).string.min_len = 1];
}

message AddDeviceRequest {
  // the device id to register
  string id = 1;

  // the name of the push notification provider (eg. apn-production)
  string push_provider_name = 2;

  // the id of the user the device is registered to, only server-side requests can provide this
  string user_id = 3;
}

message AddDeviceResponse {
  Device device = 1;
}

message RemoveDeviceRequest {
  string id = 1;
  string user_id = 2;
}

message RemoveDeviceResponse {
}

message ListDevicesRequest {
  // the id of the user, only server-side requests can provide this
  string user_id = 1;
}

message ListDevicesResponse {
  repeated Device devices = 1;
}

message CreateUserRequest {
  string id = 1;
  repeated string teams = 2;
  string role = 3;
  google.protobuf.Struct custom = 4;
  string name = 5;
  string image_url = 6;
}

// CreateOrUpdateUsersRequest runs a partial update or create on the list of users
// specify replace = true to do a hard update instead of partial update
message CreateOrUpdateUsersRequest {
  repeated CreateUserRequest users = 1;
  bool full_update =2; // full update (defaults to false and does a partial update)
}

message CreateOrUpdateUsersResponse {
  repeated User users = 1;
}

message DeleteUserRequest {
  string id = 1;
}

// TODO: do we support both soft and hard delete
message ExportUserRequest {
  string id = 1;
}

// TODO: talk about what data we should export on the GDPR endpoints for a user
message ExportUserResponse {
  string id = 1;
}

message DeleteUserResponse {
  string id = 1;
}

message CreateUserResponse {
  User user = 1;
}

message SendCustomEventRequest {
  string type = 1;
  bytes data = 2;
}

message SendCustomEventResponse {
}

message JoinCallRequest {
  string id = 1;
  string type = 2;
}

message UserCapability {
  string action = 1;
  string description = 2;
}

message JoinCallResponse {
  User user = 1;
  Call call = 2;
  CallState call_state = 3;
  repeated Edge edges = 4;
  repeated UserCapability own_capabilities = 5;
}

message LeaveCallRequest {

}

message LeaveCallResponse {
}

message EndCallRequest {

}

message EndCallResponse {
}

message StartBroadcastRequest {
  // call id and type
  string call_id = 1;
  string call_type = 2;

  // toggles HLS broadcasting on/off
  bool hls_broadcast = 3;

  // enables rtmp broadcasting
  RTMPOptions rtmp = 5;
}

message StartBroadcastResponse {
  Broadcast broadcast = 1;
}

message StopBroadcastRequest {
}

message StopBroadcastResponse {
}

message TranscribeCallRequest {
  // TODO: research what options we need here
}

message TranscribeCallResponse {
}

message StopTranscribeCallRequest {
}

message StopTranscribeCallResponse {
}

message StoreLatencyRequest {
}

message StoreLatencyResponse {
}

message StartRecordingRequest {
  string call_type = 1;
  string call_id = 2;
}

message StoreCallStatsRequest {
  // The call type
  string call_type = 1;
  // The call id
  string call_id = 2;
  // A WebRTC Stats report, as defined in https://www.w3.org/TR/webrtc/#dom-rtcstatsreport
  google.protobuf.Struct stats = 3;
}

enum CallStatEventType {
  AUDIO_FROZEN = 0;
  AUDIO_DELAY = 1;
  VIDEO_FROZEN = 2;
  VIDEO_DELAY = 3;
  VIDEO_NOT_OPTIMAL = 4;
}

message CallStatEvent {
  CallStatEventType type = 1;
  // call creation date as RFC3339 string
  string time = 2 [(validate.rules).string.min_len = 1];
}

message ReportIssueRequest {
  string call_type = 1;
  string call_id = 2;
  // optional description
  string description = 3;
  google.protobuf.Struct custom = 4;
}

message ReviewCallRequest {
  string call_type = 1;
  string call_id = 2;
  // rating between 0 and 5 stars
  float stars = 3;
  // optional description
  string description = 4;
  // optional custom data
  google.protobuf.Struct custom = 5;
}

message ReviewCallResponse {

}

message ReportIssueResponse {

}

message ParticipantCallStatEvent {
  string participant_id = 1;
  repeated CallStatEvent call_timeline = 2;

}

message GetCallStatsRequest {
  string call_type = 1;
  string call_id = 2;


}

message CallStats {
  repeated CallStatEvent call_timeline = 1;
  repeated ParticipantCallStatEvent participant_timelines = 2;
}

message GetCallStatsResponse {
  Call call = 1;
  CallStats call_stats = 2;
}

message StoreCallStatsResponse {}

message StartRecordingResponse {
}

message StopRecordingRequest {
  string call_type = 1;
  string call_id = 2;
}

message StopRecordingResponse {
  string s3_file_url = 1;
}

// TODO: how do we do filtering and pagination with proto?
// here we need to be able to filter, sort and limit by
// call id, call custom attribute, call creation time, call including a user, call by type
message GetRecordingsRequest {
}

message GetRecordingsResponse {
  message Recording {
    string call_type = 1;
    string call_id = 2;
    string s3_file_url = 3;
    string start_time = 4;
    string stop_time = 5;
  }

  repeated Recording recordings = 1;
}

enum UserEventType {
  USER_EVENT_TYPE_AUDIO_MUTED_UNSPECIFIED = 0;
  USER_EVENT_TYPE_AUDIO_UNMUTED = 1;
  USER_EVENT_TYPE_VIDEO_STARTED = 2;
  USER_EVENT_TYPE_VIDEO_STOPPED = 3;
}

message SendEventRequest {
  string user_id = 1;
  string call_type = 2;
  string call_id = 3;
  UserEventType event_type = 4;
}

message SendEventResponse {
}
