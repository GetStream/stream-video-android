syntax = "proto3";

package stream.video;

import "google/protobuf/struct.proto";
import "google/protobuf/wrappers.proto";
import "validate/validate.proto";
import "video_models/models.proto";

option go_package = "github.com/GetStream/video/protobuf/video_coordinator_rpc";

service CallCoordinatorService {
  // CreateCall creates a new call that is unique for the combination of type and id fields
  // If a call with the same type and id already exists then the call will be updated based on the request (if allowed and if needed)
  // The user calling this endpoint will be created if necessary ({id: id})
  // The users listed in the participants field will also be created if necessary ({id: id})
  rpc CreateCall(CreateCallRequest) returns (CreateCallResponse);

  // GetCall retrieves the state for one call, the user calling this endpoint is created if missing
  rpc GetCall(GetCallRequest) returns (GetCallResponse);

  rpc UpdateCall(UpdateCallRequest) returns (UpdateCallResponse);
  rpc DeleteCall(DeleteCallRequest) returns (DeleteCallResponse);

  // JoinCall returns the call state and the list of edges that the user should be check for latency
  // this endpoint is meant to be used to prepare the information needed to call the SelectEdgeServer endpoint
  rpc JoinCall(JoinCallRequest) returns (JoinCallResponse);

  rpc SelectEdgeServer(SelectEdgeServerRequest) returns(SelectEdgeServerResponse);
  rpc LeaveCall(LeaveCallRequest) returns (LeaveCallResponse);
  rpc EndCall(EndCallRequest) returns (EndCallResponse);

  // AddDevice registers the mobile device for push notifications
  // this endpoint will create the user if missing
  // if a device with the same id and push_provider_name exists, then the operation will be ignored
  rpc AddDevice(AddDeviceRequest) returns (AddDeviceResponse);

  rpc RemoveDevice(RemoveDeviceRequest) returns (RemoveDeviceResponse);
  rpc ListDevices(ListDevicesRequest) returns (ListDevicesResponse);

  // add reaction should perhaps just be handled by chat
  rpc SendCustomEvent(SendCustomEventRequest) returns (SendCustomEventResponse);

  // room is a confusing name. better to call it breakout room
  // breakout rooms have their own audio/video track
  // breakout rooms have their own chat
  /**
  TODO
  rpc CreateBreakoutRoom(CreateBreakoutRoomRequest) returns (CreateBreakoutRoomResponse);
  rpc JoinBreakoutRoom() returns ();
  rpc LeaveBreakoutRoom() returns ();
  rpc DeleteBreakoutRoom() returns ();
  */

  // server side sync & advanced endpoints
  rpc CreateOrUpdateCalls(CreateOrUpdateCallsRequest) returns (CreateOrUpdateCallsResponse);
  rpc CreateOrUpdateUsers(CreateOrUpdateUsersRequest) returns (CreateOrUpdateUsersResponse);

  // recording a call or transcribing a call can be
  // A. Enabled by default for a call type
  // B. Enabled when creating the call per the default call type settings
  // C. Configured differently for that specific call
  // D. Enabled during the call
  rpc TranscribeCall(TranscribeCallRequest) returns (TranscribeCallResponse);
  rpc StopTranscribeCall(StopTranscribeCallRequest) returns (StopTranscribeCallResponse);

  // start broadcast/ stop broadcast to HLS, RTMP and storage
  rpc StartBroadcast(StartBroadcastRequest) returns (StartBroadcastResponse);
  rpc StopBroadcast(StopBroadcastRequest) returns (StartBroadcastResponse);

  // User & GDPR endpoints, delete user
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);
  rpc ExportUser(ExportUserRequest) returns (ExportUserResponse);
  // This requires having some sort of user/team level concept

  // call recording endpoints
  rpc StartRecording(StartRecordingRequest) returns (StartRecordingResponse);
  rpc StopRecording(StopRecordingRequest) returns (StopRecordingResponse);
  rpc GetRecordings(GetRecordingsRequest) returns (GetRecordingsResponse);

  // endpoints needed to build a good dashboard experience
  // - listing calls and filtering based on their attributes
  // - listing users and filtering based on their attributes
}

message GetCallRequest {
  string id = 1;
  string type = 2;
}

message GetCallResponse {
  Call call = 1;
  CallState call_state = 2;
}

message CreateOrUpdateCallsRequest {
  repeated CreateCallRequest calls = 1;
}

message CreateOrUpdateCallsResponse {
  repeated Call calls = 1;
}

message CreateCallRequest {
  // the call type
  string type = 1;

  // the call id, if not provided a unique value will be generated based on UUID v4
  string id = 2;

  // call custom data
  google.protobuf.Struct custom = 3;

  // the list of participant ids
  repeated string participant_ids = 4;

  // broadcasting, overrides the default call type setting if provided
  google.protobuf.BoolValue broadcast = 6;

  // the broadcasting options, only relevant if broadcast is enabled
  repeated BroadcastOptions broadcast_options = 7;

  // transcription, overrides the default call type setting if provided
  google.protobuf.BoolValue transcribe = 8;

  // the transcription options for this call, only relevant if transcribe is enabled
  TranscribeOptions transcribe_options = 9;

  // the recording option, overrides the default call type setting if provided
  google.protobuf.BoolValue recording = 10;

  // the ring option, overrides the default call type setting if provided
  google.protobuf.BoolValue notify = 11;
}

message CreateCallResponse {
  Call call = 1 [(validate.rules).message.required = true];
}

message UpdateCallRequest {
  string id = 1;
  string type = 2;
  bytes json_encoded_custom_data = 3;
  // TODO: additional options and overrides to default settings
}
message UpdateCallResponse {
  Call call = 1;
}

message DeleteCallRequest {
  string id = 1;
}
message DeleteCallResponse {
}

message SelectEdgeServerRequest {
  string call_id = 1;
  map<string, Latency> latency_by_edge = 3;
}

message SelectEdgeServerResponse {
  // the edge server hosting the video call
  EdgeServer edge_server = 1;

  // the auth token needed to authenticate to the edge server
  string token = 2 [(validate.rules).string.min_len = 1];
}

message AddDeviceRequest {
  // the device id to register
  string id = 1;

  // the name of the push notification provider (eg. apn-production)
  string push_provider_name = 2;

  // the id of the user the device is registered to, only server-side requests can provide this
  string user_id = 3;
}

message AddDeviceResponse {
  Device device = 1;
}

message RemoveDeviceRequest {
  string id = 1;
}

message RemoveDeviceResponse {
}

message ListDevicesRequest {
  // the id of the user, only server-side requests can provide this
  string user_id = 1;
}

message ListDevicesResponse {
  repeated Device devices = 1;
}

message CreateUserRequest {
  string id = 1;
}

message CreateOrUpdateUsersRequest {
  repeated CreateUserRequest users = 1;
}

message CreateOrUpdateUsersResponse {
  repeated User users = 1;
}

message DeleteUserRequest {
  string id = 1;
}

// TODO: do we support both soft and hard delete
message ExportUserRequest {
  string id = 1;
}

// TODO: talk about what data we should export on the GDPR endpoints for a user
message ExportUserResponse {
  string id = 1;
}

message DeleteUserResponse {
  string id = 1;
}

message CreateUserResponse {
  User user = 1;
}

message SendCustomEventRequest {
  string type = 1;
  bytes data = 2;
}

message SendCustomEventResponse {
}

message JoinCallRequest {
  string id = 1;
  string type = 2;
}

message UserCapability {
  string action = 1;
  string description = 2;
}

message JoinCallResponse {
  User user = 1;
  Call call = 2;
  CallState call_state = 3;
  repeated Edge edges = 4;
  repeated UserCapability own_capabilities = 5;
}

message LeaveCallRequest {

}

message LeaveCallResponse {
}

message EndCallRequest {

}

message EndCallResponse {
}

message StartBroadcastRequest {
  string type = 1; // initially RTMP, record and HLS
  // TODO: understand what fields we need to track here
}

message StartBroadcastResponse {
}

message StopBroadcastRequest {
}

message StopBroadcastResponse {
}

message TranscribeCallRequest {
  // TODO: research what options we need here
}

message TranscribeCallResponse {
}

message StopTranscribeCallRequest {
}

message StopTranscribeCallResponse {
}

message StoreLatencyRequest {
}

message StoreLatencyResponse {
}

message StartRecordingRequest {
  string call_id = 1;
  RecordingStorageOptions storage_options = 2;
  Codec codec = 3;
}

message StartRecordingResponse {
}

message StopRecordingRequest {
  string call_id = 1;
}

message StopRecordingResponse {
}

// TODO: how do we do filtering and pagination with proto?
// here we need to be able to filter, sort and limit by
// call id, call custom attribute, call creation time, call including a user, call by type
message GetRecordingsRequest {
}

message GetRecordingsResponse {
}
