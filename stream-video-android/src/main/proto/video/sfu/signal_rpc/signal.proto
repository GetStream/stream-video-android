syntax = "proto3";

package stream.video.sfu.signal;

import "video/sfu/models/models.proto";

option go_package = "sfu_signal_rpc";

service SignalServer {

  // SetPublisher sends the WebRTC offer for the peer connection used to publish A/V
  rpc SetPublisher(SetPublisherRequest) returns (SetPublisherResponse);

  // answer is sent by the client to the SFU after receiving a subscriber_offer.
  rpc SendAnswer(SendAnswerRequest) returns (SendAnswerResponse);

  // SendICECandidate sends an ICE candidate to the client
  rpc IceTrickle(models.ICETrickle) returns (ICETrickleResponse);

  // UpdateSubscribers is used to notify the SFU about the list of video subscriptions
  // TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user
  rpc UpdateSubscriptions(UpdateSubscriptionsRequest) returns (UpdateSubscriptionsResponse);

  rpc UpdateMuteState(UpdateMuteStateRequest) returns (UpdateMuteStateResponse);

  rpc RequestVideoQuality(UpdateVideoQualityRequest) returns (UpdateVideoQualityResponse);
}

message UpdateVideoQualityRequest{
  repeated stream.video.sfu.models.StreamQuality stream_qualities = 1;
  string session_id = 2;
}

message UpdateVideoQualityResponse{

}

message UpdateMuteStateRequest{
  string session_id = 1;
  oneof mute {
    AudioMuteChanged  audio_mute_changed = 2;
    VideoMuteChanged  video_mute_changed = 3;
  }
}

message UpdateMuteStateResponse{

}

message AudioMuteChanged {
  bool muted = 1;
}

message VideoMuteChanged {
  bool muted = 2;
}

message UpdateSubscriptionsRequest {
  // maps stream user_ids to its size
  map<string, stream.video.sfu.models.VideoDimension> subscriptions = 1;
  string session_id = 2;
}

message SendAnswerRequest {
  stream.video.sfu.models.PeerType peer_type = 1;
  string sdp = 2;
  string session_id = 4;
}

message SendAnswerResponse {

}

message IceCandidateRequest{
  // TODO: use PeerTYPE!
  bool publisher = 1;
  string candidate = 2 ;
  optional string sdp_mid = 3;
  optional uint32 sdp_mline_index = 4;
  optional string username_fragment = 5;
  string session_id = 7;
}

message ICETrickleResponse{

}

message UpdateSubscriptionsResponse {
}

message SetPublisherRequest {
  // sdp offer
  string sdp = 1;
  string session_id = 3;
}

message SetPublisherResponse {
  // sdp answer
  string sdp = 1;
  string session_id = 3;
}

message ConnectRequest {
  // peer connection sdp offer
  string sdp_offer = 1;
  // token used for authentication
  string token = 2;
}

message ConnectResponse {
  // sdp answer
  string sdp_answer = 1;
}

// Signaling related payload, all these messages will be exchanged using signaling channel
message SignalRequest {
  oneof event_payload {
    SubscribeRequest subscribe = 1;
    PublishRequest publish = 2;
  }
}

message SignalEvent {
  oneof event_payload {
    SubscribeResponse subscribe = 1;
    PublishResponse publish = 2;
  }
}
// SubscribeRequest
message SubscribeRequest {
  string token = 1;
  string sdp_offer = 2;
  // preferred quality
  string quality = 3;
}

// SubscribeResponse
message SubscribeResponse {
  // preferred quality
  string quality = 2;
}

message PublishRequest {
  string token = 1;
  string sdp_offer = 2;
}

message PublishResponse {
  string sdp_answer = 2;
}
