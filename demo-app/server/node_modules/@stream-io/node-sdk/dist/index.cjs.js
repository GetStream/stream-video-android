'use strict';

var uuid = require('uuid');
var jwt = require('jsonwebtoken');
var crypto = require('crypto');

/**
 * @export
 */
const APNConfigAuthTypeEnum = {
    CERTIFICATE: 'certificate',
    TOKEN: 'token'
};
/**
 * @export
 */
const AsyncModerationCallbackConfigModeEnum = {
    NONE: 'CALLBACK_MODE_NONE',
    REST: 'CALLBACK_MODE_REST',
    TWIRP: 'CALLBACK_MODE_TWIRP'
};
/**
 * @export
 */
const AudioSettingsDefaultDeviceEnum = {
    SPEAKER: 'speaker',
    EARPIECE: 'earpiece'
};
/**
 * @export
 */
const BlockListOptionsBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const ChannelConfigAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const ChannelConfigAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const ChannelConfigBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const ChannelConfigWithInfoAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const ChannelConfigWithInfoAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const ChannelConfigWithInfoBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const ChannelTypeConfigAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const ChannelTypeConfigAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const ChannelTypeConfigBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const CheckPushRequestPushProviderTypeEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const CheckSNSResponseStatusEnum = {
    OK: 'ok',
    ERROR: 'error'
};
/**
 * @export
 */
const CheckSQSResponseStatusEnum = {
    OK: 'ok',
    ERROR: 'error'
};
/**
 * @export
 */
const ConfigDefaultRoleEnum = {
    ATTENDEE: 'attendee',
    PUBLISHER: 'publisher',
    SUBSCRIBER: 'subscriber',
    ADMIN: 'admin'
};
/**
 * @export
 */
const CreateBlockListRequestTypeEnum = {
    REGEX: 'regex',
    DOMAIN: 'domain',
    EMAIL: 'email',
    WORD: 'word'
};
/**
 * @export
 */
const CreateCallRequestTypeEnum = {
    AUDIO: 'audio',
    VIDEO: 'video'
};
/**
 * @export
 */
const CreateChannelTypeRequestAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const CreateChannelTypeRequestAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block'
};
/**
 * @export
 */
const CreateChannelTypeRequestBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const CreateChannelTypeResponseAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const CreateChannelTypeResponseAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const CreateChannelTypeResponseBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const CreateDeviceRequestPushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const CreateExternalStorageRequestStorageTypeEnum = {
    S3: 's3',
    GCS: 'gcs',
    ABS: 'abs'
};
/**
 * @export
 */
const CreateImportRequestModeEnum = {
    INSERT: 'insert',
    UPSERT: 'upsert'
};
/**
 * @export
 */
const CreatePollRequestVotingVisibilityEnum = {
    ANONYMOUS: 'anonymous',
    PUBLIC: 'public'
};
/**
 * @export
 */
const DeleteUsersRequestCallsEnum = {
    SOFT: 'soft',
    HARD: 'hard'
};
/**
 * @export
 */
const DeleteUsersRequestConversationsEnum = {
    SOFT: 'soft',
    HARD: 'hard'
};
/**
 * @export
 */
const DeleteUsersRequestMessagesEnum = {
    SOFT: 'soft',
    PRUNING: 'pruning',
    HARD: 'hard'
};
/**
 * @export
 */
const DeleteUsersRequestUserEnum = {
    SOFT: 'soft',
    PRUNING: 'pruning',
    HARD: 'hard'
};
/**
 * @export
 */
const DevicePushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const ExternalStorageResponseTypeEnum = {
    S3: 's3',
    GCS: 'gcs',
    ABS: 'abs'
};
/**
 * @export
 */
const ImageSizeCropEnum = {
    TOP: 'top',
    BOTTOM: 'bottom',
    LEFT: 'left',
    RIGHT: 'right',
    CENTER: 'center'
};
/**
 * @export
 */
const ImageSizeResizeEnum = {
    CLIP: 'clip',
    CROP: 'crop',
    SCALE: 'scale',
    FILL: 'fill'
};
/**
 * @export
 */
const LayoutSettingsNameEnum = {
    SPOTLIGHT: 'spotlight',
    GRID: 'grid',
    SINGLE_PARTICIPANT: 'single-participant',
    MOBILE: 'mobile',
    CUSTOM: 'custom'
};
/**
 * @export
 */
const MessageTypeEnum = {
    REGULAR: 'regular',
    EPHEMERAL: 'ephemeral',
    ERROR: 'error',
    REPLY: 'reply',
    SYSTEM: 'system',
    DELETED: 'deleted'
};
/**
 * @export
 */
const MessageRequestTypeEnum = {
    REGULAR: '\'\'regular',
    SYSTEM: 'system'
};
/**
 * @export
 */
const NoiseCancellationSettingsModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const PermissionLevelEnum = {
    APP: 'app',
    CHANNEL: 'channel'
};
/**
 * @export
 */
const PolicyRequestActionEnum = {
    DENY: 'Deny',
    ALLOW: 'Allow'
};
/**
 * @export
 */
const PushConfigVersionEnum = {
    V1: 'v1',
    V2: 'v2'
};
/**
 * @export
 */
const TranscriptionSettingsModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const TranslateMessageRequestLanguageEnum = {
    AF: 'af',
    SQ: 'sq',
    AM: 'am',
    AR: 'ar',
    AZ: 'az',
    BN: 'bn',
    BS: 'bs',
    BG: 'bg',
    ZH: 'zh',
    ZH_TW: 'zh-TW',
    HR: 'hr',
    CS: 'cs',
    DA: 'da',
    FA_AF: 'fa-AF',
    NL: 'nl',
    EN: 'en',
    ET: 'et',
    FI: 'fi',
    FR: 'fr',
    FR_CA: 'fr-CA',
    KA: 'ka',
    DE: 'de',
    EL: 'el',
    HA: 'ha',
    HE: 'he',
    HI: 'hi',
    HU: 'hu',
    ID: 'id',
    IT: 'it',
    JA: 'ja',
    KO: 'ko',
    LV: 'lv',
    MS: 'ms',
    NO: 'no',
    FA: 'fa',
    PS: 'ps',
    PL: 'pl',
    PT: 'pt',
    RO: 'ro',
    RU: 'ru',
    SR: 'sr',
    SK: 'sk',
    SL: 'sl',
    SO: 'so',
    ES: 'es',
    ES_MX: 'es-MX',
    SW: 'sw',
    SV: 'sv',
    TL: 'tl',
    TA: 'ta',
    TH: 'th',
    TR: 'tr',
    UK: 'uk',
    UR: 'ur',
    VI: 'vi'
};
/**
 * @export
 */
const UpdateAppRequestEnforceUniqueUsernamesEnum = {
    NO: 'no',
    APP: 'app',
    TEAM: 'team'
};
/**
 * @export
 */
const UpdateAppRequestPermissionVersionEnum = {
    V1: 'v1',
    V2: 'v2'
};
/**
 * @export
 */
const UpdateAppRequestVideoProviderEnum = {
    AGORA: 'agora',
    HMS: 'hms'
};
/**
 * @export
 */
const UpdateChannelTypeRequestAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const UpdateChannelTypeRequestAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const UpdateChannelTypeRequestBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const UpdateChannelTypeResponseAutomodEnum = {
    DISABLED: 'disabled',
    SIMPLE: 'simple',
    AI: 'AI'
};
/**
 * @export
 */
const UpdateChannelTypeResponseAutomodBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const UpdateChannelTypeResponseBlocklistBehaviorEnum = {
    FLAG: 'flag',
    BLOCK: 'block',
    SHADOW_BLOCK: 'shadow_block'
};
/**
 * @export
 */
const UpdateExternalStorageRequestStorageTypeEnum = {
    S3: 's3',
    GCS: 'gcs',
    ABS: 'abs'
};
/**
 * @export
 */
const UpdateExternalStorageResponseTypeEnum = {
    S3: 's3',
    GCS: 'gcs',
    ABS: 'abs'
};
/**
 * @export
 */
const UpdatePollRequestVotingVisibilityEnum = {
    ANONYMOUS: 'anonymous',
    PUBLIC: 'public'
};
/**
 * @export
 */
const VideoSettingsCameraFacingEnum = {
    FRONT: 'front',
    BACK: 'back',
    EXTERNAL: 'external'
};

/**
 * @export
 */
const VideoAudioSettingsRequestDefaultDeviceEnum = {
    SPEAKER: 'speaker',
    EARPIECE: 'earpiece'
};
/**
 * @export
 */
const VideoAudioSettingsResponseDefaultDeviceEnum = {
    SPEAKER: 'speaker',
    EARPIECE: 'earpiece'
};
/**
 * @export
 */
const VideoCreateDeviceRequestPushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const VideoCreateExternalStorageRequestStorageTypeEnum = {
    S3: 's3',
    GCS: 'gcs',
    ABS: 'abs'
};
/**
 * @export
 */
const VideoDevicePushProviderEnum = {
    FIREBASE: 'firebase',
    APN: 'apn',
    HUAWEI: 'huawei',
    XIAOMI: 'xiaomi'
};
/**
 * @export
 */
const VideoExternalStorageResponseTypeEnum = {
    S3: 's3',
    GCS: 'gcs',
    ABS: 'abs'
};
/**
 * @export
 */
const VideoLayoutSettingsRequestNameEnum = {
    SPOTLIGHT: 'spotlight',
    GRID: 'grid',
    SINGLE_PARTICIPANT: 'single-participant',
    MOBILE: 'mobile',
    CUSTOM: 'custom'
};
/**
 * @export
 */
const VideoLayoutSettingsResponseNameEnum = {
    SPOTLIGHT: 'spotlight',
    GRID: 'grid',
    SINGLE_PARTICIPANT: 'single-participant',
    MOBILE: 'mobile',
    CUSTOM: 'custom'
};
/**
 * @export
 */
const VideoNoiseCancellationSettingsModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * All possibility of string to use
 * @export
 */
const VideoOwnCapability = {
    BLOCK_USERS: 'block-users',
    CHANGE_MAX_DURATION: 'change-max-duration',
    CREATE_CALL: 'create-call',
    CREATE_REACTION: 'create-reaction',
    ENABLE_NOISE_CANCELLATION: 'enable-noise-cancellation',
    END_CALL: 'end-call',
    JOIN_BACKSTAGE: 'join-backstage',
    JOIN_CALL: 'join-call',
    JOIN_ENDED_CALL: 'join-ended-call',
    MUTE_USERS: 'mute-users',
    PIN_FOR_EVERYONE: 'pin-for-everyone',
    READ_CALL: 'read-call',
    REMOVE_CALL_MEMBER: 'remove-call-member',
    SCREENSHARE: 'screenshare',
    SEND_AUDIO: 'send-audio',
    SEND_VIDEO: 'send-video',
    START_BROADCAST_CALL: 'start-broadcast-call',
    START_RECORD_CALL: 'start-record-call',
    START_TRANSCRIPTION_CALL: 'start-transcription-call',
    STOP_BROADCAST_CALL: 'stop-broadcast-call',
    STOP_RECORD_CALL: 'stop-record-call',
    STOP_TRANSCRIPTION_CALL: 'stop-transcription-call',
    UPDATE_CALL: 'update-call',
    UPDATE_CALL_MEMBER: 'update-call-member',
    UPDATE_CALL_PERMISSIONS: 'update-call-permissions',
    UPDATE_CALL_SETTINGS: 'update-call-settings'
};
/**
 * @export
 */
const VideoRecordSettingsRequestModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const VideoRecordSettingsRequestQualityEnum = {
    _360P: '360p',
    _480P: '480p',
    _720P: '720p',
    _1080P: '1080p',
    _1440P: '1440p',
    PORTRAIT_360X640: 'portrait-360x640',
    PORTRAIT_480X854: 'portrait-480x854',
    PORTRAIT_720X1280: 'portrait-720x1280',
    PORTRAIT_1080X1920: 'portrait-1080x1920',
    PORTRAIT_1440X2560: 'portrait-1440x2560'
};
/**
 * @export
 */
const VideoTranscriptionSettingsRequestModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const VideoTranscriptionSettingsResponseModeEnum = {
    AVAILABLE: 'available',
    DISABLED: 'disabled',
    AUTO_ON: 'auto-on'
};
/**
 * @export
 */
const VideoUpdateExternalStorageRequestStorageTypeEnum = {
    S3: 's3',
    GCS: 'gcs',
    ABS: 'abs'
};
/**
 * @export
 */
const VideoUpdateExternalStorageResponseTypeEnum = {
    S3: 's3',
    GCS: 'gcs',
    ABS: 'abs'
};
/**
 * @export
 */
const VideoVideoSettingsRequestCameraFacingEnum = {
    FRONT: 'front',
    BACK: 'back',
    EXTERNAL: 'external'
};
/**
 * @export
 */
const VideoVideoSettingsResponseCameraFacingEnum = {
    FRONT: 'front',
    BACK: 'back',
    EXTERNAL: 'external'
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v122.3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH$1 = "https://stream-io-api.com".replace(/\/+$/, "");
let Configuration$1 = class Configuration {
    constructor(configuration = {}) {
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring$1;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
};
const DefaultConfig$1 = new Configuration$1();
/**
 * This is the base class for all generated API classes.
 */
let BaseAPI$1 = class BaseAPI {
    constructor(configuration = DefaultConfig$1) {
        this.configuration = configuration;
        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {
            let fetchParams = { url, init };
            for (const middleware of this.middleware) {
                if (middleware.pre) {
                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            }
            catch (e) {
                for (const middleware of this.middleware) {
                    if (middleware.onError) {
                        response = (yield middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined,
                        })) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError$1(e, 'The request failed and the interceptors did not return an alternative response');
                    }
                    else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    response = (yield middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone(),
                    })) || response;
                }
            }
            return response;
        });
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    request(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, init } = yield this.createFetchParams(context, initOverrides);
            const response = yield this.fetchApi(url, init);
            if (response && (response.status >= 200 && response.status < 300)) {
                return response;
            }
            throw new ResponseError$1(response, 'Response returned an error code');
        });
    }
    createFetchParams(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.configuration.basePath + context.path;
            if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                // only add the querystring to the URL if there are query parameters.
                // this is done to avoid urls ending with a "?" character which buggy webservers
                // do not handle correctly sometimes.
                url += '?' + this.configuration.queryParamsStringify(context.query);
            }
            const headers = Object.assign({}, this.configuration.headers, context.headers);
            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
            const initOverrideFn = typeof initOverrides === "function"
                ? initOverrides
                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });
            const initParams = {
                method: context.method,
                headers,
                body: context.body,
                credentials: this.configuration.credentials,
            };
            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({
                init: initParams,
                context,
            })));
            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData$1(overriddenInit.body) ||
                    overriddenInit.body instanceof URLSearchParams ||
                    isBlob$1(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body) });
            return { url, init };
        });
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
};
BaseAPI$1.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
function isBlob$1(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData$1(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
let ResponseError$1 = class ResponseError extends Error {
    constructor(response, msg) {
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
};
let FetchError$1 = class FetchError extends Error {
    constructor(cause, msg) {
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
};
let RequiredError$1 = class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
};
const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
function querystring$1(params, prefix = '') {
    return Object.keys(params)
        .map(key => querystringSingleKey$1(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}
function querystringSingleKey$1(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey$1(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring$1(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function canConsumeForm(consumes) {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
let JSONApiResponse$1 = class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transformer(yield this.raw.json());
        });
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v122.3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class ProductchatApi extends BaseAPI$1 {
    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser
     * Ban user
     */
    banRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {
                throw new RequiredError$1('banRequest', 'Required parameter requestParameters.banRequest was null or undefined when calling ban.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/ban`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.banRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser
     * Ban user
     */
    ban(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.banRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Block users
     * Block user
     */
    blockUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.blockUsersRequest === null || requestParameters.blockUsersRequest === undefined) {
                throw new RequiredError$1('blockUsersRequest', 'Required parameter requestParameters.blockUsersRequest was null or undefined when calling blockUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/block`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.blockUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Block users
     * Block user
     */
    blockUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.blockUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Cast a vote on a poll  Sends events: - poll.vote_casted  Required permissions: - CastVote
     * Cast vote
     */
    castPollVoteRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
                throw new RequiredError$1('messageId', 'Required parameter requestParameters.messageId was null or undefined when calling castPollVote.');
            }
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling castPollVote.');
            }
            if (requestParameters.castPollVoteRequest === null || requestParameters.castPollVoteRequest === undefined) {
                throw new RequiredError$1('castPollVoteRequest', 'Required parameter requestParameters.castPollVoteRequest was null or undefined when calling castPollVote.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{message_id}/polls/{poll_id}/vote`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))).replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.castPollVoteRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Cast a vote on a poll  Sends events: - poll.vote_casted  Required permissions: - CastVote
     * Cast vote
     */
    castPollVote(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.castPollVoteRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Check External Storage
     */
    checkExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/external_storage/{name}/check`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     *
     * Check External Storage
     */
    checkExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings
     * Check push
     */
    checkPushRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {
                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_push`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkPushRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends a test message via push, this is a test endpoint to verify your push settings
     * Check push
     */
    checkPush(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkPushRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Validates Amazon SNS configuration
     * Check SNS
     */
    checkSNSRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {
                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_sns`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkSNSRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Validates Amazon SNS configuration
     * Check SNS
     */
    checkSNS(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkSNSRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Validates Amazon SQS credentials
     * Check SQS
     */
    checkSQSRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {
                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/check_sqs`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.checkSQSRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Validates Amazon SQS credentials
     * Check SQS
     */
    checkSQS(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkSQSRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Commits a pending message, which will make it visible in the channel  Sends events: - message.new - message.updated
     * Commit message
     */
    commitMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling commitMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/commit`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Commits a pending message, which will make it visible in the channel  Sends events: - message.new - message.updated
     * Commit message
     */
    commitMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.commitMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a new application blocklist, once created the blocklist can be used by any channel type
     * Create block list
     */
    createBlockListRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createBlockListRequest === null || requestParameters.createBlockListRequest === undefined) {
                throw new RequiredError$1('createBlockListRequest', 'Required parameter requestParameters.createBlockListRequest was null or undefined when calling createBlockList.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createBlockListRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates a new application blocklist, once created the blocklist can be used by any channel type
     * Create block list
     */
    createBlockList(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createBlockListRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a call  Required permissions: - CreateCall - ReadChannel
     * Create a call
     */
    createCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling createCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling createCall.');
            }
            if (requestParameters.createCallRequest === null || requestParameters.createCallRequest === undefined) {
                throw new RequiredError$1('createCallRequest', 'Required parameter requestParameters.createCallRequest was null or undefined when calling createCall.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/call`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createCallRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates a call  Required permissions: - CreateCall - ReadChannel
     * Create a call
     */
    createCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates new channel type
     * Create channel type
     */
    createChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {
                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createChannelTypeRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates new channel type
     * Create channel type
     */
    createChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates custom chat command
     * Create command
     */
    createCommandRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createCommandRequest === null || requestParameters.createCommandRequest === undefined) {
                throw new RequiredError$1('createCommandRequest', 'Required parameter requestParameters.createCommandRequest was null or undefined when calling createCommand.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createCommandRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates custom chat command
     * Create command
     */
    createCommand(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createCommandRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {
                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/devices`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createDeviceRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDevice(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createDeviceRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates new external storage
     * Create external storage
     */
    createExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createExternalStorageRequest === null || requestParameters.createExternalStorageRequest === undefined) {
                throw new RequiredError$1('createExternalStorageRequest', 'Required parameter requestParameters.createExternalStorageRequest was null or undefined when calling createExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/external_storage`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createExternalStorageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates new external storage
     * Create external storage
     */
    createExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Create Guest
     */
    createGuestRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createGuestRequest === null || requestParameters.createGuestRequest === undefined) {
                throw new RequiredError$1('createGuestRequest', 'Required parameter requestParameters.createGuestRequest was null or undefined when calling createGuest.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/guest`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createGuestRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     *
     * Create Guest
     */
    createGuest(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createGuestRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a new import
     * Create import
     */
    createImportRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createImportRequest === null || requestParameters.createImportRequest === undefined) {
                throw new RequiredError$1('createImportRequest', 'Required parameter requestParameters.createImportRequest was null or undefined when calling createImport.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/imports`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createImportRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates a new import
     * Create import
     */
    createImport(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createImportRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a new import URL
     * Create import URL
     */
    createImportURLRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createImportURLRequest === null || requestParameters.createImportURLRequest === undefined) {
                throw new RequiredError$1('createImportURLRequest', 'Required parameter requestParameters.createImportURLRequest was null or undefined when calling createImportURL.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/import_urls`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createImportURLRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates a new import URL
     * Create import URL
     */
    createImportURL(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createImportURLRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a new poll  Required permissions: - CreatePoll
     * Create poll
     */
    createPollRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createPollRequest === null || requestParameters.createPollRequest === undefined) {
                throw new RequiredError$1('createPollRequest', 'Required parameter requestParameters.createPollRequest was null or undefined when calling createPoll.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createPollRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates a new poll  Required permissions: - CreatePoll
     * Create poll
     */
    createPoll(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createPollRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates a poll option  Sends events: - poll.updated  Required permissions: - CastVote - UpdatePoll
     * Create poll option
     */
    createPollOptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling createPollOption.');
            }
            if (requestParameters.createPollOptionRequest === null || requestParameters.createPollOptionRequest === undefined) {
                throw new RequiredError$1('createPollOptionRequest', 'Required parameter requestParameters.createPollOptionRequest was null or undefined when calling createPollOption.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/{poll_id}/options`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createPollOptionRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates a poll option  Sends events: - poll.updated  Required permissions: - CastVote - UpdatePoll
     * Create poll option
     */
    createPollOption(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createPollOptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates custom role
     * Create role
     */
    createRoleRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.createRoleRequest === null || requestParameters.createRoleRequest === undefined) {
                throw new RequiredError$1('createRoleRequest', 'Required parameter requestParameters.createRoleRequest was null or undefined when calling createRole.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/roles`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.createRoleRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Creates custom role
     * Create role
     */
    createRole(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createRoleRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated
     * Deactivate user
     */
    deactivateUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');
            }
            if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {
                throw new RequiredError$1('deactivateUserRequest', 'Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}/deactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.deactivateUserRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated
     * Deactivate user
     */
    deactivateUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deactivateUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deactivate users in batches  Sends events: - user.deactivated
     * Deactivate users
     */
    deactivateUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {
                throw new RequiredError$1('deactivateUsersRequest', 'Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/deactivate`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.deactivateUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deactivate users in batches  Sends events: - user.deactivated
     * Deactivate users
     */
    deactivateUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deactivateUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes previously created application blocklist
     * Delete block list
     */
    deleteBlockListRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteBlockList.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes previously created application blocklist
     * Delete block list
     */
    deleteBlockList(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteBlockListRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel
     * Delete channel
     */
    deleteChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteChannel.');
            }
            const queryParameters = {};
            if (requestParameters.hardDelete !== undefined) {
                queryParameters['hard_delete'] = requestParameters.hardDelete;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel
     * Delete channel
     */
    deleteChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes channel type
     * Delete channel type
     */
    deleteChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes channel type
     * Delete channel type
     */
    deleteChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel
     * Deletes channels asynchronously
     */
    deleteChannelsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.deleteChannelsRequest === null || requestParameters.deleteChannelsRequest === undefined) {
                throw new RequiredError$1('deleteChannelsRequest', 'Required parameter requestParameters.deleteChannelsRequest was null or undefined when calling deleteChannels.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/delete`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.deleteChannelsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel
     * Deletes channels asynchronously
     */
    deleteChannels(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteChannelsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes custom chat command
     * Delete command
     */
    deleteCommandRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCommand.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes custom chat command
     * Delete command
     */
    deleteCommand(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteCommandRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes one device
     * Delete device
     */
    deleteDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteDevice.');
            }
            const queryParameters = {};
            if (requestParameters.id !== undefined) {
                queryParameters['id'] = requestParameters.id;
            }
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/devices`,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes one device
     * Delete device
     */
    deleteDevice(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes external storage
     * Delete external storage
     */
    deleteExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes external storage
     * Delete external storage
     */
    deleteExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes previously uploaded file  Required permissions: - DeleteAttachment
     * Delete file
     */
    deleteFileRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteFile.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteFile.');
            }
            const queryParameters = {};
            if (requestParameters.url !== undefined) {
                queryParameters['url'] = requestParameters.url;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/file`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes previously uploaded file  Required permissions: - DeleteAttachment
     * Delete file
     */
    deleteFile(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteFileRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes previously uploaded image  Required permissions: - DeleteAttachment
     * Delete image
     */
    deleteImageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteImage.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteImage.');
            }
            const queryParameters = {};
            if (requestParameters.url !== undefined) {
                queryParameters['url'] = requestParameters.url;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/image`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes previously uploaded image  Required permissions: - DeleteAttachment
     * Delete image
     */
    deleteImage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteImageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage
     * Delete message
     */
    deleteMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteMessage.');
            }
            const queryParameters = {};
            if (requestParameters.hard !== undefined) {
                queryParameters['hard'] = requestParameters.hard;
            }
            if (requestParameters.deletedBy !== undefined) {
                queryParameters['deleted_by'] = requestParameters.deletedBy;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage
     * Delete message
     */
    deleteMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes a poll  Sends events: - poll.deleted  Required permissions: - DeletePoll
     * Delete poll
     */
    deletePollRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling deletePoll.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/{poll_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes a poll  Sends events: - poll.deleted  Required permissions: - DeletePoll
     * Delete poll
     */
    deletePoll(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deletePollRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes a poll option  Sends events: - poll.updated  Required permissions: - UpdatePoll
     * Delete poll option
     */
    deletePollOptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling deletePollOption.');
            }
            if (requestParameters.optionId === null || requestParameters.optionId === undefined) {
                throw new RequiredError$1('optionId', 'Required parameter requestParameters.optionId was null or undefined when calling deletePollOption.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/{poll_id}/options/{option_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))).replace(`{${"option_id"}}`, encodeURIComponent(String(requestParameters.optionId))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes a poll option  Sends events: - poll.updated  Required permissions: - UpdatePoll
     * Delete poll option
     */
    deletePollOption(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deletePollOptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint
     * Delete a push provider
     */
    deletePushProviderRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');
            }
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/push_providers/{type}/{name}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Delete a push provider from v2 with multi bundle/package support. v1 isn\'t supported in this endpoint
     * Delete a push provider
     */
    deletePushProvider(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction
     * Delete reaction
     */
    deleteReactionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteReaction.');
            }
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteReaction.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/reaction/{type}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction
     * Delete reaction
     */
    deleteReaction(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteReactionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes custom role
     * Delete role
     */
    deleteRoleRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteRole.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/roles/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes custom role
     * Delete role
     */
    deleteRole(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteRoleRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted
     * Delete Users
     */
    deleteUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {
                throw new RequiredError$1('deleteUsersRequest', 'Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/delete`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.deleteUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted
     * Delete Users
     */
    deleteUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Exports channel data to JSON file
     * Export channels
     */
    exportChannelsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.exportChannelsRequest === null || requestParameters.exportChannelsRequest === undefined) {
                throw new RequiredError$1('exportChannelsRequest', 'Required parameter requestParameters.exportChannelsRequest was null or undefined when calling exportChannels.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/export_channels`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.exportChannelsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Exports channel data to JSON file
     * Export channels
     */
    exportChannels(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.exportChannelsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions
     * Export user
     */
    exportUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling exportUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}/export`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Exports the user\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions
     * Export user
     */
    exportUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.exportUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Exports user profile, reactions and messages for list of given users
     * Export users
     */
    exportUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {
                throw new RequiredError$1('exportUsersRequest', 'Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/export/users`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.exportUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Exports user profile, reactions and messages for list of given users
     * Export users
     */
    exportUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.exportUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser
     * Flag
     */
    flagRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {
                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/flag`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.flagRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser
     * Flag
     */
    flag(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.flagRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * This Method returns the application settings
     * Get App Settings
     */
    getAppRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/app`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * This Method returns the application settings
     * Get App Settings
     */
    getApp(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAppRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns block list by given name
     * Get block list
     */
    getBlockListRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getBlockList.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns block list by given name
     * Get block list
     */
    getBlockList(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getBlockListRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Get list of blocked Users
     * Get list of blocked Users
     */
    getBlockedUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/block`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Get list of blocked Users
     * Get list of blocked Users
     */
    getBlockedUsers(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getBlockedUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Retrieves the token to join a call  Required permissions: - JoinCall - ReadChannel
     * Get Call Token
     */
    getCallTokenRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.getCallTokenRequest === null || requestParameters.getCallTokenRequest === undefined) {
                throw new RequiredError$1('getCallTokenRequest', 'Required parameter requestParameters.getCallTokenRequest was null or undefined when calling getCallToken.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/calls`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.getCallTokenRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Retrieves the token to join a call  Required permissions: - JoinCall - ReadChannel
     * Get Call Token
     */
    getCallToken(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCallTokenRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Retrieves the token to join a call  Required permissions: - JoinCall - ReadChannel
     * Get Call Token
     */
    getCallToken_1Raw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.callId === null || requestParameters.callId === undefined) {
                throw new RequiredError$1('callId', 'Required parameter requestParameters.callId was null or undefined when calling getCallToken_1.');
            }
            if (requestParameters.getCallTokenRequest === null || requestParameters.getCallTokenRequest === undefined) {
                throw new RequiredError$1('getCallTokenRequest', 'Required parameter requestParameters.getCallTokenRequest was null or undefined when calling getCallToken_1.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/calls/{call_id}`.replace(`{${"call_id"}}`, encodeURIComponent(String(requestParameters.callId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.getCallTokenRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Retrieves the token to join a call  Required permissions: - JoinCall - ReadChannel
     * Get Call Token
     */
    getCallToken_1(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCallToken_1Raw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets channel type
     * Get channel type
     */
    getChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets channel type
     * Get channel type
     */
    getChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns custom command by its name
     * Get command
     */
    getCommandRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getCommand.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns custom command by its name
     * Get command
     */
    getCommand(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCommandRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Export channels status
     */
    getExportChannelsStatusRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getExportChannelsStatus.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/export_channels/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     *
     * Export channels status
     */
    getExportChannelsStatus(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getExportChannelsStatusRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets an import
     * Get import
     */
    getImportRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getImport.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/imports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets an import
     * Get import
     */
    getImport(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getImportRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns list messages found by IDs  Required permissions: - ReadChannel
     * Get many messages
     */
    getManyMessagesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getManyMessages.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getManyMessages.');
            }
            if (requestParameters.ids === null || requestParameters.ids === undefined) {
                throw new RequiredError$1('ids', 'Required parameter requestParameters.ids was null or undefined when calling getManyMessages.');
            }
            const queryParameters = {};
            if (requestParameters.ids) {
                queryParameters['ids'] = requestParameters.ids;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/messages`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns list messages found by IDs  Required permissions: - ReadChannel
     * Get many messages
     */
    getManyMessages(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getManyMessagesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns message by ID  Required permissions: - ReadChannel
     * Get message
     */
    getMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getMessage.');
            }
            const queryParameters = {};
            if (requestParameters.showDeletedMessage !== undefined) {
                queryParameters['show_deleted_message'] = requestParameters.showDeletedMessage;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns message by ID  Required permissions: - ReadChannel
     * Get message
     */
    getMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Get an OpenGraph attachment for a link
     * Get OG
     */
    getOGRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.url === null || requestParameters.url === undefined) {
                throw new RequiredError$1('url', 'Required parameter requestParameters.url was null or undefined when calling getOG.');
            }
            const queryParameters = {};
            if (requestParameters.url !== undefined) {
                queryParameters['url'] = requestParameters.url;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/og`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Get an OpenGraph attachment for a link
     * Get OG
     */
    getOG(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getOGRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * This Method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start
     * Get or create channel
     */
    getOrCreateChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateChannel.');
            }
            if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {
                throw new RequiredError$1('channelGetOrCreateRequest', 'Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/query`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.channelGetOrCreateRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * This Method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start
     * Get or create channel
     */
    getOrCreateChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getOrCreateChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * This Method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start
     * Get or create channel
     */
    getOrCreateDistinctChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateDistinctChannel.');
            }
            if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {
                throw new RequiredError$1('channelGetOrCreateRequest', 'Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateDistinctChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/query`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.channelGetOrCreateRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * This Method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start
     * Get or create channel
     */
    getOrCreateDistinctChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getOrCreateDistinctChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets custom permission
     * Get permission
     */
    getPermissionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getPermission.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/permissions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets custom permission
     * Get permission
     */
    getPermission(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getPermissionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Retrieves a poll
     * Get poll
     */
    getPollRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling getPoll.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/{poll_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Retrieves a poll
     * Get poll
     */
    getPoll(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getPollRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Retrieves a poll option
     * Get poll option
     */
    getPollOptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling getPollOption.');
            }
            if (requestParameters.optionId === null || requestParameters.optionId === undefined) {
                throw new RequiredError$1('optionId', 'Required parameter requestParameters.optionId was null or undefined when calling getPollOption.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/{poll_id}/options/{option_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))).replace(`{${"option_id"}}`, encodeURIComponent(String(requestParameters.optionId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Retrieves a poll option
     * Get poll option
     */
    getPollOption(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getPollOptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Get rate limits usage and quotas
     * Get rate limits
     */
    getRateLimitsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.serverSide !== undefined) {
                queryParameters['server_side'] = requestParameters.serverSide;
            }
            if (requestParameters.android !== undefined) {
                queryParameters['android'] = requestParameters.android;
            }
            if (requestParameters.ios !== undefined) {
                queryParameters['ios'] = requestParameters.ios;
            }
            if (requestParameters.web !== undefined) {
                queryParameters['web'] = requestParameters.web;
            }
            if (requestParameters.endpoints !== undefined) {
                queryParameters['endpoints'] = requestParameters.endpoints;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/rate_limits`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Get rate limits usage and quotas
     * Get rate limits
     */
    getRateLimits(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getRateLimitsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns list of reactions of specific message  Required permissions: - ReadChannel
     * Get reactions
     */
    getReactionsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getReactions.');
            }
            const queryParameters = {};
            if (requestParameters.limit !== undefined) {
                queryParameters['limit'] = requestParameters.limit;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/reactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns list of reactions of specific message  Required permissions: - ReadChannel
     * Get reactions
     */
    getReactions(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getReactionsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns replies (thread) of the message  Required permissions: - ReadChannel
     * Get replies
     */
    getRepliesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.parentId === null || requestParameters.parentId === undefined) {
                throw new RequiredError$1('parentId', 'Required parameter requestParameters.parentId was null or undefined when calling getReplies.');
            }
            const queryParameters = {};
            if (requestParameters.sort) {
                queryParameters['sort'] = requestParameters.sort;
            }
            if (requestParameters.limit !== undefined) {
                queryParameters['limit'] = requestParameters.limit;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.idGte !== undefined) {
                queryParameters['id_gte'] = requestParameters.idGte;
            }
            if (requestParameters.idGt !== undefined) {
                queryParameters['id_gt'] = requestParameters.idGt;
            }
            if (requestParameters.idLte !== undefined) {
                queryParameters['id_lte'] = requestParameters.idLte;
            }
            if (requestParameters.idLt !== undefined) {
                queryParameters['id_lt'] = requestParameters.idLt;
            }
            if (requestParameters.createdAtAfterOrEqual !== undefined) {
                queryParameters['created_at_after_or_equal'] = requestParameters.createdAtAfterOrEqual;
            }
            if (requestParameters.createdAtAfter !== undefined) {
                queryParameters['created_at_after'] = requestParameters.createdAtAfter;
            }
            if (requestParameters.createdAtBeforeOrEqual !== undefined) {
                queryParameters['created_at_before_or_equal'] = requestParameters.createdAtBeforeOrEqual;
            }
            if (requestParameters.createdAtBefore !== undefined) {
                queryParameters['created_at_before'] = requestParameters.createdAtBefore;
            }
            if (requestParameters.idAround !== undefined) {
                queryParameters['id_around'] = requestParameters.idAround;
            }
            if (requestParameters.createdAtAround !== undefined) {
                queryParameters['created_at_around'] = requestParameters.createdAtAround;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{parent_id}/replies`.replace(`{${"parent_id"}}`, encodeURIComponent(String(requestParameters.parentId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns replies (thread) of the message  Required permissions: - ReadChannel
     * Get replies
     */
    getReplies(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getRepliesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets status of a task
     * Get status of a task
     */
    getTaskRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getTask.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/tasks/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets status of a task
     * Get status of a task
     */
    getTask(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getTaskRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Return a specific thread  Required permissions: - ReadChannel
     * Get Thread
     */
    getThreadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
                throw new RequiredError$1('messageId', 'Required parameter requestParameters.messageId was null or undefined when calling getThread.');
            }
            const queryParameters = {};
            if (requestParameters.connectionId !== undefined) {
                queryParameters['connection_id'] = requestParameters.connectionId;
            }
            if (requestParameters.replyLimit !== undefined) {
                queryParameters['reply_limit'] = requestParameters.replyLimit;
            }
            if (requestParameters.participantLimit !== undefined) {
                queryParameters['participant_limit'] = requestParameters.participantLimit;
            }
            if (requestParameters.memberLimit !== undefined) {
                queryParameters['member_limit'] = requestParameters.memberLimit;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/threads/{message_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Return a specific thread  Required permissions: - ReadChannel
     * Get Thread
     */
    getThread(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getThreadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel
     * Hide channel
     */
    hideChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling hideChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling hideChannel.');
            }
            if (requestParameters.hideChannelRequest === null || requestParameters.hideChannelRequest === undefined) {
                throw new RequiredError$1('hideChannelRequest', 'Required parameter requestParameters.hideChannelRequest was null or undefined when calling hideChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/hide`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.hideChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel
     * Hide channel
     */
    hideChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.hideChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns all available block lists
     * List block lists
     */
    listBlockListsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns all available block lists
     * List block lists
     */
    listBlockLists(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listBlockListsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists all available channel types
     * List channel types
     */
    listChannelTypesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Lists all available channel types
     * List channel types
     */
    listChannelTypes(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listChannelTypesRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns all custom commands
     * List commands
     */
    listCommandsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns all custom commands
     * List commands
     */
    listCommands(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listCommandsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns all available devices
     * List devices
     */
    listDevicesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/devices`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns all available devices
     * List devices
     */
    listDevices(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listDevicesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists external storage
     * List external storage
     */
    listExternalStorageRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/external_storage`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Lists external storage
     * List external storage
     */
    listExternalStorage(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listExternalStorageRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets an import
     * Get import
     */
    listImportsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/imports`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Gets an import
     * Get import
     */
    listImports(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listImportsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists all available permissions
     * List permissions
     */
    listPermissionsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/permissions`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Lists all available permissions
     * List permissions
     */
    listPermissions(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listPermissionsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * List details of all push providers.
     * List push providers
     */
    listPushProvidersRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/push_providers`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * List details of all push providers.
     * List push providers
     */
    listPushProviders(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listPushProvidersRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists all available roles
     * List roles
     */
    listRolesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/roles`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Lists all available roles
     * List roles
     */
    listRoles(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listRolesRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark channels as read
     */
    markChannelsReadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {
                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/read`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markChannelsReadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark channels as read
     */
    markChannelsRead(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark read
     */
    markReadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');
            }
            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {
                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/read`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markReadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel
     * Mark read
     */
    markRead(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markReadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel
     * Mark unread
     */
    markUnreadRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');
            }
            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {
                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/unread`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.markUnreadRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Marks channel as unread from a specific message  Required permissions: - ReadChannel
     * Mark unread
     */
    markUnread(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.markUnreadRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel
     * Mute channel
     */
    muteChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.muteChannelRequest === null || requestParameters.muteChannelRequest === undefined) {
                throw new RequiredError$1('muteChannelRequest', 'Required parameter requestParameters.muteChannelRequest was null or undefined when calling muteChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/mute/channel`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.muteChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel
     * Mute channel
     */
    muteChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.muteChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser
     * Mute user
     */
    muteUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {
                throw new RequiredError$1('muteUserRequest', 'Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/mute`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.muteUserRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser
     * Mute user
     */
    muteUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.muteUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel
     * Query Banned Users
     */
    queryBannedUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/query_banned_users`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel
     * Query Banned Users
     */
    queryBannedUsers(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryBannedUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Query channels with filter query  Required permissions: - ReadChannel
     * Query channels
     */
    queryChannelsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.queryChannelsRequest === null || requestParameters.queryChannelsRequest === undefined) {
                throw new RequiredError$1('queryChannelsRequest', 'Required parameter requestParameters.queryChannelsRequest was null or undefined when calling queryChannels.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.queryChannelsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Query channels with filter query  Required permissions: - ReadChannel
     * Query channels
     */
    queryChannels(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryChannelsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Find and filter channel members  Required permissions: - ReadChannel
     * Query members
     */
    queryMembersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/members`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Find and filter channel members  Required permissions: - ReadChannel
     * Query members
     */
    queryMembers(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryMembersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Find and filter message flags  Required permissions: - ReadMessageFlags
     * Query Message Flags
     */
    queryMessageFlagsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/flags/message`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Find and filter message flags  Required permissions: - ReadMessageFlags
     * Query Message Flags
     */
    queryMessageFlags(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryMessageFlagsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Queries history for one message
     * Query message history
     */
    queryMessageHistoryRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.queryMessageHistoryRequest === null || requestParameters.queryMessageHistoryRequest === undefined) {
                throw new RequiredError$1('queryMessageHistoryRequest', 'Required parameter requestParameters.queryMessageHistoryRequest was null or undefined when calling queryMessageHistory.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/history`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.queryMessageHistoryRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Queries history for one message
     * Query message history
     */
    queryMessageHistory(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryMessageHistoryRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Queries votes
     * Query votes
     */
    queryPollVotesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling queryPollVotes.');
            }
            if (requestParameters.queryPollVotesRequest === null || requestParameters.queryPollVotesRequest === undefined) {
                throw new RequiredError$1('queryPollVotesRequest', 'Required parameter requestParameters.queryPollVotesRequest was null or undefined when calling queryPollVotes.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/{poll_id}/votes`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.queryPollVotesRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Queries votes
     * Query votes
     */
    queryPollVotes(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryPollVotesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Queries polls
     * Query polls
     */
    queryPollsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.queryPollsRequest === null || requestParameters.queryPollsRequest === undefined) {
                throw new RequiredError$1('queryPollsRequest', 'Required parameter requestParameters.queryPollsRequest was null or undefined when calling queryPolls.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/query`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.queryPollsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Queries polls
     * Query polls
     */
    queryPolls(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryPollsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Get reactions on a message  Required permissions: - ReadChannel
     */
    queryReactionsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling queryReactions.');
            }
            if (requestParameters.queryReactionsRequest === null || requestParameters.queryReactionsRequest === undefined) {
                throw new RequiredError$1('queryReactionsRequest', 'Required parameter requestParameters.queryReactionsRequest was null or undefined when calling queryReactions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/reactions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.queryReactionsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Get reactions on a message  Required permissions: - ReadChannel
     */
    queryReactions(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryReactionsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns the list of threads for specific user  Required permissions: - ReadChannel
     * Query Threads
     */
    queryThreadsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.queryThreadsRequest === null || requestParameters.queryThreadsRequest === undefined) {
                throw new RequiredError$1('queryThreadsRequest', 'Required parameter requestParameters.queryThreadsRequest was null or undefined when calling queryThreads.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/threads`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.queryThreadsRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Returns the list of threads for specific user  Required permissions: - ReadChannel
     * Query Threads
     */
    queryThreads(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryThreadsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Find and filter users  Required permissions: - SearchUser
     * Query users
     */
    queryUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Find and filter users  Required permissions: - SearchUser
     * Query users
     */
    queryUsers(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated
     * Reactivate user
     */
    reactivateUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');
            }
            if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {
                throw new RequiredError$1('reactivateUserRequest', 'Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}/reactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.reactivateUserRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Activates user who\'s been deactivated previously  Sends events: - user.reactivated
     * Reactivate user
     */
    reactivateUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.reactivateUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Reactivate users in batches  Sends events: - user.reactivated
     * Reactivate users
     */
    reactivateUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {
                throw new RequiredError$1('reactivateUsersRequest', 'Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/reactivate`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.reactivateUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Reactivate users in batches  Sends events: - user.reactivated
     * Reactivate users
     */
    reactivateUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.reactivateUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Delete a vote from a poll  Sends events: - poll.vote_removed  Required permissions: - CastVote
     * Delete vote
     */
    removePollVoteRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
                throw new RequiredError$1('messageId', 'Required parameter requestParameters.messageId was null or undefined when calling removePollVote.');
            }
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling removePollVote.');
            }
            if (requestParameters.voteId === null || requestParameters.voteId === undefined) {
                throw new RequiredError$1('voteId', 'Required parameter requestParameters.voteId was null or undefined when calling removePollVote.');
            }
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{message_id}/polls/{poll_id}/vote/{vote_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))).replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))).replace(`{${"vote_id"}}`, encodeURIComponent(String(requestParameters.voteId))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Delete a vote from a poll  Sends events: - poll.vote_removed  Required permissions: - CastVote
     * Delete vote
     */
    removePollVote(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.removePollVoteRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Restore soft deleted users
     * Restore users
     */
    restoreUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {
                throw new RequiredError$1('restoreUsersRequest', 'Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/restore`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.restoreUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Restore soft deleted users
     * Restore users
     */
    restoreUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.restoreUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction
     * Run message command action
     */
    runMessageActionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling runMessageAction.');
            }
            if (requestParameters.messageActionRequest === null || requestParameters.messageActionRequest === undefined) {
                throw new RequiredError$1('messageActionRequest', 'Required parameter requestParameters.messageActionRequest was null or undefined when calling runMessageAction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/action`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.messageActionRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction
     * Run message command action
     */
    runMessageAction(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.runMessageActionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Search messages across channels  Required permissions: - ReadChannel
     * Search messages
     */
    searchRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.payload !== undefined) {
                queryParameters['payload'] = requestParameters.payload;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/search`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Search messages across channels  Required permissions: - ReadChannel
     * Search messages
     */
    search(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends event to the channel  Required permissions: - SendCustomEvent
     * Send event
     */
    sendEventRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');
            }
            if (requestParameters.sendEventRequest === null || requestParameters.sendEventRequest === undefined) {
                throw new RequiredError$1('sendEventRequest', 'Required parameter requestParameters.sendEventRequest was null or undefined when calling sendEvent.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/event`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.sendEventRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends event to the channel  Required permissions: - SendCustomEvent
     * Send event
     */
    sendEvent(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendEventRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel
     * Send new message
     */
    sendMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendMessage.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendMessage.');
            }
            if (requestParameters.sendMessageRequest === null || requestParameters.sendMessageRequest === undefined) {
                throw new RequiredError$1('sendMessageRequest', 'Required parameter requestParameters.sendMessageRequest was null or undefined when calling sendMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/message`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.sendMessageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel
     * Send new message
     */
    sendMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel
     * Send reaction
     */
    sendReactionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendReaction.');
            }
            if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {
                throw new RequiredError$1('sendReactionRequest', 'Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendReaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/reaction`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.sendReactionRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel
     * Send reaction
     */
    sendReaction(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendReactionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends a custom event to a user  Sends events: - *
     * Send user event
     */
    sendUserCustomEventRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.userId === null || requestParameters.userId === undefined) {
                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling sendUserCustomEvent.');
            }
            if (requestParameters.sendUserCustomEventRequest === null || requestParameters.sendUserCustomEventRequest === undefined) {
                throw new RequiredError$1('sendUserCustomEventRequest', 'Required parameter requestParameters.sendUserCustomEventRequest was null or undefined when calling sendUserCustomEvent.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/{user_id}/event`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.sendUserCustomEventRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Sends a custom event to a user  Sends events: - *
     * Send user event
     */
    sendUserCustomEvent(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendUserCustomEventRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Shows previously hidden channel  Sends events: - channel.visible
     * Show channel
     */
    showChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling showChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling showChannel.');
            }
            if (requestParameters.showChannelRequest === null || requestParameters.showChannelRequest === undefined) {
                throw new RequiredError$1('showChannelRequest', 'Required parameter requestParameters.showChannelRequest was null or undefined when calling showChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/show`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.showChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Shows previously hidden channel  Sends events: - channel.visible
     * Show channel
     */
    showChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.showChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel
     * Translate message
     */
    translateMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling translateMessage.');
            }
            if (requestParameters.translateMessageRequest === null || requestParameters.translateMessageRequest === undefined) {
                throw new RequiredError$1('translateMessageRequest', 'Required parameter requestParameters.translateMessageRequest was null or undefined when calling translateMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/translate`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.translateMessageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel
     * Translate message
     */
    translateMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.translateMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel
     * Truncate channel
     */
    truncateChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling truncateChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling truncateChannel.');
            }
            if (requestParameters.truncateChannelRequest === null || requestParameters.truncateChannelRequest === undefined) {
                throw new RequiredError$1('truncateChannelRequest', 'Required parameter requestParameters.truncateChannelRequest was null or undefined when calling truncateChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/truncate`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.truncateChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel
     * Truncate channel
     */
    truncateChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.truncateChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser
     * Unban user
     */
    unbanRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.targetUserId === null || requestParameters.targetUserId === undefined) {
                throw new RequiredError$1('targetUserId', 'Required parameter requestParameters.targetUserId was null or undefined when calling unban.');
            }
            const queryParameters = {};
            if (requestParameters.targetUserId !== undefined) {
                queryParameters['target_user_id'] = requestParameters.targetUserId;
            }
            if (requestParameters.channelCid !== undefined) {
                queryParameters['channel_cid'] = requestParameters.channelCid;
            }
            if (requestParameters.createdBy !== undefined) {
                queryParameters['created_by'] = requestParameters.createdBy;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/ban`,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser
     * Unban user
     */
    unban(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unbanRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Unblock users
     * Unblock user
     */
    unblockUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.unblockUsersRequest === null || requestParameters.unblockUsersRequest === undefined) {
                throw new RequiredError$1('unblockUsersRequest', 'Required parameter requestParameters.unblockUsersRequest was null or undefined when calling unblockUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users/unblock`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.unblockUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Unblock users
     * Unblock user
     */
    unblockUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unblockUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Undelete a message that was previously soft-deleted  Sends events: - message.undeleted
     * Undelete message
     */
    undeleteMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling undeleteMessage.');
            }
            if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {
                throw new RequiredError$1('updateMessageRequest', 'Required parameter requestParameters.updateMessageRequest was null or undefined when calling undeleteMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}/undelete`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateMessageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Undelete a message that was previously soft-deleted  Sends events: - message.undeleted
     * Undelete message
     */
    undeleteMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.undeleteMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel
     * Unmute channel
     */
    unmuteChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.unmuteChannelRequest === null || requestParameters.unmuteChannelRequest === undefined) {
                throw new RequiredError$1('unmuteChannelRequest', 'Required parameter requestParameters.unmuteChannelRequest was null or undefined when calling unmuteChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/unmute/channel`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.unmuteChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel
     * Unmute channel
     */
    unmuteChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unmuteChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser
     * Unmute user
     */
    unmuteUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {
                throw new RequiredError$1('unmuteUserRequest', 'Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/moderation/unmute`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.unmuteUserRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser
     * Unmute user
     */
    unmuteUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unmuteUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Fetch unread counts for a single user
     * Unread counts
     */
    unreadCountsRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/unread`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Fetch unread counts for a single user
     * Unread counts
     */
    unreadCounts(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unreadCountsRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Fetch unread counts in batch for multiple users in one call
     * Batch unread counts
     */
    unreadCountsBatchRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.unreadCountsBatchRequest === null || requestParameters.unreadCountsBatchRequest === undefined) {
                throw new RequiredError$1('unreadCountsBatchRequest', 'Required parameter requestParameters.unreadCountsBatchRequest was null or undefined when calling unreadCountsBatch.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/unread_batch`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.unreadCountsBatchRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Fetch unread counts in batch for multiple users in one call
     * Batch unread counts
     */
    unreadCountsBatch(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unreadCountsBatchRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * This Method updates one or more application settings
     * Update App Settings
     */
    updateAppRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.updateAppRequest === null || requestParameters.updateAppRequest === undefined) {
                throw new RequiredError$1('updateAppRequest', 'Required parameter requestParameters.updateAppRequest was null or undefined when calling updateApp.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/app`,
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateAppRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * This Method updates one or more application settings
     * Update App Settings
     */
    updateApp(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateAppRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates contents of the block list
     * Update block list
     */
    updateBlockListRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateBlockList.');
            }
            if (requestParameters.updateBlockListRequest === null || requestParameters.updateBlockListRequest === undefined) {
                throw new RequiredError$1('updateBlockListRequest', 'Required parameter requestParameters.updateBlockListRequest was null or undefined when calling updateBlockList.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/blocklists/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateBlockListRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates contents of the block list
     * Update block list
     */
    updateBlockList(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateBlockListRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers
     * Update channel
     */
    updateChannelRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannel.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannel.');
            }
            if (requestParameters.updateChannelRequest === null || requestParameters.updateChannelRequest === undefined) {
                throw new RequiredError$1('updateChannelRequest', 'Required parameter requestParameters.updateChannelRequest was null or undefined when calling updateChannel.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateChannelRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers
     * Update channel
     */
    updateChannel(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateChannelRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen
     * Partially update channel
     */
    updateChannelPartialRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannelPartial.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannelPartial.');
            }
            if (requestParameters.updateChannelPartialRequest === null || requestParameters.updateChannelPartialRequest === undefined) {
                throw new RequiredError$1('updateChannelPartialRequest', 'Required parameter requestParameters.updateChannelPartialRequest was null or undefined when calling updateChannelPartial.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateChannelPartialRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen
     * Partially update channel
     */
    updateChannelPartial(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateChannelPartialRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates channel type
     * Update channel type
     */
    updateChannelTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');
            }
            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {
                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/channeltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateChannelTypeRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates channel type
     * Update channel type
     */
    updateChannelType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates custom chat command
     * Update command
     */
    updateCommandRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateCommand.');
            }
            if (requestParameters.updateCommandRequest === null || requestParameters.updateCommandRequest === undefined) {
                throw new RequiredError$1('updateCommandRequest', 'Required parameter requestParameters.updateCommandRequest was null or undefined when calling updateCommand.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/commands/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateCommandRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates custom chat command
     * Update command
     */
    updateCommand(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCommandRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Update External Storage
     */
    updateExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');
            }
            if (requestParameters.updateExternalStorageRequest === null || requestParameters.updateExternalStorageRequest === undefined) {
                throw new RequiredError$1('updateExternalStorageRequest', 'Required parameter requestParameters.updateExternalStorageRequest was null or undefined when calling updateExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateExternalStorageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     *
     * Update External Storage
     */
    updateExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Update message
     */
    updateMessageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessage.');
            }
            if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {
                throw new RequiredError$1('updateMessageRequest', 'Required parameter requestParameters.updateMessageRequest was null or undefined when calling updateMessage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateMessageRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Update message
     */
    updateMessage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateMessageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Partially message update
     */
    updateMessagePartialRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessagePartial.');
            }
            if (requestParameters.updateMessagePartialRequest === null || requestParameters.updateMessagePartialRequest === undefined) {
                throw new RequiredError$1('updateMessagePartialRequest', 'Required parameter requestParameters.updateMessagePartialRequest was null or undefined when calling updateMessagePartial.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/messages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateMessagePartialRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage
     * Partially message update
     */
    updateMessagePartial(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateMessagePartialRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates a poll  Sends events: - poll.closed - poll.updated  Required permissions: - UpdatePoll
     * Update poll
     */
    updatePollRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.updatePollRequest === null || requestParameters.updatePollRequest === undefined) {
                throw new RequiredError$1('updatePollRequest', 'Required parameter requestParameters.updatePollRequest was null or undefined when calling updatePoll.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls`,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updatePollRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates a poll  Sends events: - poll.closed - poll.updated  Required permissions: - UpdatePoll
     * Update poll
     */
    updatePoll(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updatePollRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates a poll option  Sends events: - poll.updated  Required permissions: - UpdatePoll
     * Update poll option
     */
    updatePollOptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling updatePollOption.');
            }
            if (requestParameters.updatePollOptionRequest === null || requestParameters.updatePollOptionRequest === undefined) {
                throw new RequiredError$1('updatePollOptionRequest', 'Required parameter requestParameters.updatePollOptionRequest was null or undefined when calling updatePollOption.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/{poll_id}/options`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updatePollOptionRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates a poll option  Sends events: - poll.updated  Required permissions: - UpdatePoll
     * Update poll option
     */
    updatePollOption(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updatePollOptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates a poll partially  Sends events: - poll.updated  Required permissions: - UpdatePoll
     * Partial update poll
     */
    updatePollPartialRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.pollId === null || requestParameters.pollId === undefined) {
                throw new RequiredError$1('pollId', 'Required parameter requestParameters.pollId was null or undefined when calling updatePollPartial.');
            }
            if (requestParameters.updatePollPartialRequest === null || requestParameters.updatePollPartialRequest === undefined) {
                throw new RequiredError$1('updatePollPartialRequest', 'Required parameter requestParameters.updatePollPartialRequest was null or undefined when calling updatePollPartial.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/polls/{poll_id}`.replace(`{${"poll_id"}}`, encodeURIComponent(String(requestParameters.pollId))),
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updatePollPartialRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates a poll partially  Sends events: - poll.updated  Required permissions: - UpdatePoll
     * Partial update poll
     */
    updatePollPartial(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updatePollPartialRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates certain fields of the thread  Sends events: - thread.updated  Required permissions: - ReadChannel - UpdateThread
     * Partially update thread
     */
    updateThreadPartialRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
                throw new RequiredError$1('messageId', 'Required parameter requestParameters.messageId was null or undefined when calling updateThreadPartial.');
            }
            if (requestParameters.updateThreadPartialRequest === null || requestParameters.updateThreadPartialRequest === undefined) {
                throw new RequiredError$1('updateThreadPartialRequest', 'Required parameter requestParameters.updateThreadPartialRequest was null or undefined when calling updateThreadPartial.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/threads/{message_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateThreadPartialRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates certain fields of the thread  Sends events: - thread.updated  Required permissions: - ReadChannel - UpdateThread
     * Partially update thread
     */
    updateThreadPartial(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateThreadPartialRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Update or create users in bulk  Sends events: - user.updated
     * Upsert users
     */
    updateUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {
                throw new RequiredError$1('updateUsersRequest', 'Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateUsersRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Update or create users in bulk  Sends events: - user.updated
     * Upsert users
     */
    updateUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated
     * Partially update user
     */
    updateUsersPartialRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.updateUsersPartialRequest === null || requestParameters.updateUsersPartialRequest === undefined) {
                throw new RequiredError$1('updateUsersPartialRequest', 'Required parameter requestParameters.updateUsersPartialRequest was null or undefined when calling updateUsersPartial.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/users`,
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.updateUsersPartialRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated
     * Partially update user
     */
    updateUsersPartial(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateUsersPartialRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Uploads file  Required permissions: - UploadAttachment
     * Upload file
     */
    uploadFileRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadFile.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadFile.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const consumes = [
                { contentType: 'multipart/form-data' },
            ];
            // @ts-ignore: canConsumeForm may be unused
            canConsumeForm(consumes);
            let formParams;
            {
                formParams = new URLSearchParams();
            }
            if (requestParameters.file !== undefined) {
                formParams.append('file', requestParameters.file);
            }
            if (requestParameters.user !== undefined) {
                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: "application/json", }));
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/file`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Uploads file  Required permissions: - UploadAttachment
     * Upload file
     */
    uploadFile(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.uploadFileRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Uploads image  Required permissions: - UploadAttachment
     * Upload image
     */
    uploadImageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadImage.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadImage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const consumes = [
                { contentType: 'multipart/form-data' },
            ];
            // @ts-ignore: canConsumeForm may be unused
            canConsumeForm(consumes);
            let formParams;
            {
                formParams = new URLSearchParams();
            }
            if (requestParameters.file !== undefined) {
                formParams.append('file', requestParameters.file);
            }
            if (requestParameters.uploadSizes) {
                formParams.append('upload_sizes', requestParameters.uploadSizes.join(COLLECTION_FORMATS["csv"]));
            }
            if (requestParameters.user !== undefined) {
                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: "application/json", }));
            }
            const response = yield this.request({
                path: `/channels/{type}/{id}/image`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: formParams,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Uploads image  Required permissions: - UploadAttachment
     * Upload image
     */
    uploadImage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.uploadImageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Upsert a push provider for v2 with multi bundle/package support
     * Upsert a push provider
     */
    upsertPushProviderRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.upsertPushProviderRequest === null || requestParameters.upsertPushProviderRequest === undefined) {
                throw new RequiredError$1('upsertPushProviderRequest', 'Required parameter requestParameters.upsertPushProviderRequest was null or undefined when calling upsertPushProvider.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/push_providers`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.upsertPushProviderRequest,
            }, initOverrides);
            return new JSONApiResponse$1(response);
        });
    }
    /**
     * Upsert a push provider for v2 with multi bundle/package support
     * Upsert a push provider
     */
    upsertPushProvider(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.upsertPushProviderRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

class StreamChannel {
    constructor(streamClient, type, id) {
        this.streamClient = streamClient;
        this.type = type;
        this.id = id;
        this.delete = (request) => {
            return this.chatApi.deleteChannel(Object.assign(Object.assign({}, this.baseRequest), (request !== null && request !== void 0 ? request : {})));
        };
        this.update = (updateChannelRequest) => {
            return this.chatApi.updateChannel(Object.assign(Object.assign({}, this.baseRequest), { updateChannelRequest }));
        };
        this.updatePartial = (updateChannelPartialRequest) => {
            return this.chatApi.updateChannelPartial(Object.assign(Object.assign({}, this.baseRequest), { updateChannelPartialRequest }));
        };
        this.getOrCreate = (channelGetOrCreateRequest) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            if (this.id) {
                return yield this.chatApi.getOrCreateChannel(Object.assign(Object.assign({}, this.baseRequest), { channelGetOrCreateRequest: channelGetOrCreateRequest !== null && channelGetOrCreateRequest !== void 0 ? channelGetOrCreateRequest : {} }));
            }
            else {
                if (!((_a = channelGetOrCreateRequest === null || channelGetOrCreateRequest === void 0 ? void 0 : channelGetOrCreateRequest.data) === null || _a === void 0 ? void 0 : _a.members)) {
                    throw new Error('You need to provide members to create a channel without ID');
                }
                const response = yield this.chatApi.getOrCreateDistinctChannel({
                    type: this.type,
                    channelGetOrCreateRequest,
                });
                this.id = (_b = response.channel) === null || _b === void 0 ? void 0 : _b.id;
                return response;
            }
        });
        this.markRead = (markReadRequest) => {
            return this.chatApi.markRead(Object.assign(Object.assign({}, this.baseRequest), { markReadRequest }));
        };
        this.markUnread = (markUnreadRequest) => {
            return this.chatApi.markUnread(Object.assign(Object.assign({}, this.baseRequest), { markUnreadRequest }));
        };
        this.show = (showChannelRequest) => {
            return this.chatApi.showChannel(Object.assign(Object.assign({}, this.baseRequest), { showChannelRequest }));
        };
        this.hide = (hideChannelRequest) => {
            return this.chatApi.hideChannel(Object.assign(Object.assign({}, this.baseRequest), { hideChannelRequest }));
        };
        this.truncate = (truncateChannelRequest) => {
            return this.chatApi.truncateChannel(Object.assign(Object.assign({}, this.baseRequest), { truncateChannelRequest }));
        };
        this.queryMembers = (request) => {
            return this.chatApi.queryMembers({
                payload: Object.assign(Object.assign({}, this.baseRequest), request),
            });
        };
        this.mute = (muteChannelRequest) => {
            return this.chatApi.muteChannel({
                muteChannelRequest: Object.assign(Object.assign({}, muteChannelRequest), { channel_cids: [this.cid] }),
            });
        };
        this.unmute = (unmuteChannelRequest) => {
            return this.chatApi.unmuteChannel({
                unmuteChannelRequest: Object.assign(Object.assign({}, unmuteChannelRequest), { channel_cids: [this.cid] }),
            });
        };
        // TODO: there is probably an issue with the generated code here
        // uploadFile = (options: Omit<OmitTypeId<UploadFileRequest>, 'file'>, file: Buffer) => {
        //   return this.chatApi.uploadFile({...options, ...this.baseRequest, file: file as any as string});
        // }
        // deleteFile = (request: OmitTypeId<DeleteFileRequest>) => {
        //   return this.chatApi.deleteFile({...request, ...this.baseRequest});
        // }
        // uploadImage = (request: OmitTypeId<UploadImageRequest>) => {
        //   return this.chatApi.uploadImage({...request, ...this.baseRequest});
        // }
        // deleteImage = (request: OmitTypeId<DeleteImageRequest>) => {
        //   return this.chatApi.deleteImage({...request, ...this.baseRequest});
        // }
        this.sendMessage = (sendMessageRequest) => {
            return this.chatApi.sendMessage(Object.assign(Object.assign({}, this.baseRequest), { sendMessageRequest }));
        };
        this.deleteMessage = (request) => {
            return this.chatApi.deleteMessage(request);
        };
        this.updateMessage = (id, updateMessageRequest) => {
            return this.chatApi.updateMessage({ id, updateMessageRequest });
        };
        this.updateMessagePartial = (id, updateMessagePartialRequest) => {
            return this.chatApi.updateMessagePartial({
                id,
                updateMessagePartialRequest,
            });
        };
        this.getMessage = (request) => {
            return this.chatApi.getMessage(request);
        };
        this.getManyMessages = (request) => {
            return this.chatApi.getManyMessages(Object.assign(Object.assign({}, request), this.baseRequest));
        };
        this.translateMessage = (id, translateMessageRequest) => {
            return this.chatApi.translateMessage({ id, translateMessageRequest });
        };
        this.getMessagesAround = (request) => {
            return this.chatApi.getReplies(request);
        };
        this.getOpenGraphData = (request) => {
            return this.chatApi.getOG(request);
        };
        this.sendMessageReaction = (messageId, sendReactionRequest) => {
            return this.chatApi.sendReaction({
                id: messageId,
                sendReactionRequest,
            });
        };
        this.deleteMessageReaction = (messageId, request) => {
            return this.chatApi.deleteReaction(Object.assign(Object.assign({}, request), { id: messageId }));
        };
        this.getMessageReactions = (messageId, request) => {
            return this.chatApi.getReactions(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), { id: messageId }));
        };
        this.sendCustomEvent = (event) => {
            return this.chatApi.sendEvent(Object.assign(Object.assign({}, this.baseRequest), { sendEventRequest: { event } }));
        };
        const configuration = this.streamClient.getConfiguration();
        /** @ts-expect-error */
        this.chatApi = new ProductchatApi(configuration);
    }
    get cid() {
        return `${this.baseRequest.type}:${this.baseRequest.id}`;
    }
    get baseRequest() {
        if (!this.id) {
            throw new Error('You need to initialize the channel with `getOrCreate`');
        }
        return {
            id: this.id,
            type: this.type,
        };
    }
}

class StreamChatClient {
    constructor(streamClient) {
        this.streamClient = streamClient;
        this.channel = (type, id) => {
            return new StreamChannel(this.streamClient, type, id);
        };
        this.createBlockList = (createBlockListRequest) => {
            return this.chatApi.createBlockList({ createBlockListRequest });
        };
        this.listBlockLists = () => {
            return this.chatApi.listBlockLists();
        };
        this.getBlockList = (request) => {
            return this.chatApi.getBlockList(request);
        };
        this.updateBlockList = (name, updateBlockListRequest) => {
            return this.chatApi.updateBlockList({ name, updateBlockListRequest });
        };
        this.deleteBlockList = (request) => {
            return this.chatApi.deleteBlockList(request);
        };
        this.createChannelType = (createChannelTypeRequest) => {
            return this.chatApi.createChannelType({ createChannelTypeRequest });
        };
        this.deleteChannelType = (request) => {
            return this.chatApi.deleteChannelType(request);
        };
        this.getChannelType = (request) => {
            return this.chatApi.getChannelType(request);
        };
        this.listChannelTypes = () => {
            return this.chatApi.listChannelTypes();
        };
        this.updateChannelType = (name, updateChannelTypeRequest) => {
            return this.chatApi.updateChannelType({
                name,
                updateChannelTypeRequest,
            });
        };
        this.queryChannels = (queryChannelsRequest) => {
            return this.chatApi.queryChannels({
                queryChannelsRequest: queryChannelsRequest !== null && queryChannelsRequest !== void 0 ? queryChannelsRequest : {},
            });
        };
        this.searchMessages = (payload) => {
            return this.chatApi.search({ payload });
        };
        this.exportChannels = (exportChannelsRequest) => {
            return this.chatApi.exportChannels({
                exportChannelsRequest: exportChannelsRequest !== null && exportChannelsRequest !== void 0 ? exportChannelsRequest : null,
            });
        };
        this.getExportStatus = (request) => {
            return this.chatApi.getExportChannelsStatus(request);
        };
        this.listCommands = () => {
            return this.chatApi.listCommands();
        };
        this.createCommand = (createCommandRequest) => {
            return this.chatApi.createCommand({ createCommandRequest });
        };
        this.getCommand = (getCommandRequest) => {
            return this.chatApi.getCommand(getCommandRequest);
        };
        this.updateCommand = (name, updateCommandRequest) => {
            return this.chatApi.updateCommand({ name, updateCommandRequest });
        };
        this.deleteCommand = (request) => {
            return this.chatApi.deleteCommand(request);
        };
        const configuration = this.streamClient.getConfiguration();
        /** @ts-expect-error */
        this.chatApi = new ProductchatApi(configuration);
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v122.3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH = "https://stream-io-api.com".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}) {
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
const DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI {
    constructor(configuration = DefaultConfig) {
        this.configuration = configuration;
        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {
            let fetchParams = { url, init };
            for (const middleware of this.middleware) {
                if (middleware.pre) {
                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            }
            catch (e) {
                for (const middleware of this.middleware) {
                    if (middleware.onError) {
                        response = (yield middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined,
                        })) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    }
                    else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    response = (yield middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone(),
                    })) || response;
                }
            }
            return response;
        });
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    request(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, init } = yield this.createFetchParams(context, initOverrides);
            const response = yield this.fetchApi(url, init);
            if (response && (response.status >= 200 && response.status < 300)) {
                return response;
            }
            throw new ResponseError(response, 'Response returned an error code');
        });
    }
    createFetchParams(context, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.configuration.basePath + context.path;
            if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                // only add the querystring to the URL if there are query parameters.
                // this is done to avoid urls ending with a "?" character which buggy webservers
                // do not handle correctly sometimes.
                url += '?' + this.configuration.queryParamsStringify(context.query);
            }
            const headers = Object.assign({}, this.configuration.headers, context.headers);
            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});
            const initOverrideFn = typeof initOverrides === "function"
                ? initOverrides
                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });
            const initParams = {
                method: context.method,
                headers,
                body: context.body,
                credentials: this.configuration.credentials,
            };
            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({
                init: initParams,
                context,
            })));
            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData(overriddenInit.body) ||
                    overriddenInit.body instanceof URLSearchParams ||
                    isBlob(overriddenInit.body)
                    ? overriddenInit.body
                    : JSON.stringify(overriddenInit.body) });
            return { url, init };
        });
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg) {
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
class FetchError extends Error {
    constructor(cause, msg) {
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
function querystring(params, prefix = '') {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
            .join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transformer(yield this.raw.json());
        });
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Stream API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v122.3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 */
class ProductvideoApi extends BaseAPI {
    /**
     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser
     * Block user on a call
     */
    blockUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling blockUser.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling blockUser.');
            }
            if (requestParameters.videoBlockUserRequest === null || requestParameters.videoBlockUserRequest === undefined) {
                throw new RequiredError('videoBlockUserRequest', 'Required parameter requestParameters.videoBlockUserRequest was null or undefined when calling blockUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/block`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoBlockUserRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser
     * Block user on a call
     */
    blockUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.blockUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Check External Storage
     */
    checkExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage/{name}/check`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Check External Storage
     */
    checkExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.checkExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Required permissions: - JoinCall
     * Collect user feedback
     */
    collectUserFeedbackRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling collectUserFeedback.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling collectUserFeedback.');
            }
            if (requestParameters.session === null || requestParameters.session === undefined) {
                throw new RequiredError('session', 'Required parameter requestParameters.session was null or undefined when calling collectUserFeedback.');
            }
            if (requestParameters.videoCollectUserFeedbackRequest === null || requestParameters.videoCollectUserFeedbackRequest === undefined) {
                throw new RequiredError('videoCollectUserFeedbackRequest', 'Required parameter requestParameters.videoCollectUserFeedbackRequest was null or undefined when calling collectUserFeedback.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/feedback/{session}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCollectUserFeedbackRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Required permissions: - JoinCall
     * Collect user feedback
     */
    collectUserFeedback(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.collectUserFeedbackRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Create Call Type
     */
    createCallTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoCreateCallTypeRequest === null || requestParameters.videoCreateCallTypeRequest === undefined) {
                throw new RequiredError('videoCreateCallTypeRequest', 'Required parameter requestParameters.videoCreateCallTypeRequest was null or undefined when calling createCallType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCreateCallTypeRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Create Call Type
     */
    createCallType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createCallTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoCreateDeviceRequest === null || requestParameters.videoCreateDeviceRequest === undefined) {
                throw new RequiredError('videoCreateDeviceRequest', 'Required parameter requestParameters.videoCreateDeviceRequest was null or undefined when calling createDevice.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/devices`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCreateDeviceRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Adds a new device to a user, if the same device already exists the call will have no effect
     * Create device
     */
    createDevice(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createDeviceRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Creates new external storage
     * Create external storage
     */
    createExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoCreateExternalStorageRequest === null || requestParameters.videoCreateExternalStorageRequest === undefined) {
                throw new RequiredError('videoCreateExternalStorageRequest', 'Required parameter requestParameters.videoCreateExternalStorageRequest was null or undefined when calling createExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCreateExternalStorageRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Creates new external storage
     * Create external storage
     */
    createExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Create Guest
     */
    createGuestRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoCreateGuestRequest === null || requestParameters.videoCreateGuestRequest === undefined) {
                throw new RequiredError('videoCreateGuestRequest', 'Required parameter requestParameters.videoCreateGuestRequest was null or undefined when calling createGuest.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/guest`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoCreateGuestRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Create Guest
     */
    createGuest(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.createGuestRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.deleted  Required permissions: - DeleteCall
     * Delete Call
     */
    deleteCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling deleteCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling deleteCall.');
            }
            if (requestParameters.videoDeleteCallRequest === null || requestParameters.videoDeleteCallRequest === undefined) {
                throw new RequiredError('videoDeleteCallRequest', 'Required parameter requestParameters.videoDeleteCallRequest was null or undefined when calling deleteCall.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/delete`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoDeleteCallRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.deleted  Required permissions: - DeleteCall
     * Delete Call
     */
    deleteCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Delete Call Type
     */
    deleteCallTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCallType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Delete Call Type
     */
    deleteCallType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteCallTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes one device
     * Delete device
     */
    deleteDeviceRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling deleteDevice.');
            }
            const queryParameters = {};
            if (requestParameters.id !== undefined) {
                queryParameters['id'] = requestParameters.id;
            }
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/devices`,
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Deletes one device
     * Delete device
     */
    deleteDevice(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes external storage
     * Delete external storage
     */
    deleteExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Deletes external storage
     * Delete external storage
     */
    deleteExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes recording  Required permissions: - DeleteRecording
     * Delete recording
     */
    deleteRecordingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling deleteRecording.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling deleteRecording.');
            }
            if (requestParameters.session === null || requestParameters.session === undefined) {
                throw new RequiredError('session', 'Required parameter requestParameters.session was null or undefined when calling deleteRecording.');
            }
            if (requestParameters.filename === null || requestParameters.filename === undefined) {
                throw new RequiredError('filename', 'Required parameter requestParameters.filename was null or undefined when calling deleteRecording.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/{session}/recordings/{filename}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))).replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters.filename))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Deletes recording  Required permissions: - DeleteRecording
     * Delete recording
     */
    deleteRecording(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteRecordingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Deletes transcription  Required permissions: - DeleteTranscription
     * Delete transcription
     */
    deleteTranscriptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling deleteTranscription.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling deleteTranscription.');
            }
            if (requestParameters.session === null || requestParameters.session === undefined) {
                throw new RequiredError('session', 'Required parameter requestParameters.session was null or undefined when calling deleteTranscription.');
            }
            if (requestParameters.filename === null || requestParameters.filename === undefined) {
                throw new RequiredError('filename', 'Required parameter requestParameters.filename was null or undefined when calling deleteTranscription.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/{session}/transcriptions/{filename}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))).replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters.filename))),
                method: 'DELETE',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Deletes transcription  Required permissions: - DeleteTranscription
     * Delete transcription
     */
    deleteTranscription(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.deleteTranscriptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.ended  Required permissions: - EndCall
     * End call
     */
    endCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling endCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling endCall.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/mark_ended`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.ended  Required permissions: - EndCall
     * End call
     */
    endCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.endCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Required permissions: - ReadCall
     * Get Call
     */
    getCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getCall.');
            }
            const queryParameters = {};
            if (requestParameters.membersLimit !== undefined) {
                queryParameters['members_limit'] = requestParameters.membersLimit;
            }
            if (requestParameters.ring !== undefined) {
                queryParameters['ring'] = requestParameters.ring;
            }
            if (requestParameters.notify !== undefined) {
                queryParameters['notify'] = requestParameters.notify;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Required permissions: - ReadCall
     * Get Call
     */
    getCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Required permissions: - ReadCallStats
     * Get Call Stats
     */
    getCallStatsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getCallStats.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getCallStats.');
            }
            if (requestParameters.session === null || requestParameters.session === undefined) {
                throw new RequiredError('session', 'Required parameter requestParameters.session was null or undefined when calling getCallStats.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stats/{session}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"session"}}`, encodeURIComponent(String(requestParameters.session))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Required permissions: - ReadCallStats
     * Get Call Stats
     */
    getCallStats(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCallStatsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Get Call Type
     */
    getCallTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getCallType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Get Call Type
     */
    getCallType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getCallTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns the list of all edges available for video calls.
     * Get Edges
     */
    getEdgesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/edges`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Returns the list of all edges available for video calls.
     * Get Edges
     */
    getEdges(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getEdgesRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings
     * Get or create a call
     */
    getOrCreateCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateCall.');
            }
            if (requestParameters.videoGetOrCreateCallRequest === null || requestParameters.videoGetOrCreateCallRequest === undefined) {
                throw new RequiredError('videoGetOrCreateCallRequest', 'Required parameter requestParameters.videoGetOrCreateCallRequest was null or undefined when calling getOrCreateCall.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoGetOrCreateCallRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings
     * Get or create a call
     */
    getOrCreateCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getOrCreateCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.live_started  Required permissions: - UpdateCall
     * Set call as live
     */
    goLiveRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling goLive.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling goLive.');
            }
            if (requestParameters.videoGoLiveRequest === null || requestParameters.videoGoLiveRequest === undefined) {
                throw new RequiredError('videoGoLiveRequest', 'Required parameter requestParameters.videoGoLiveRequest was null or undefined when calling goLive.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/go_live`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoGoLiveRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.live_started  Required permissions: - UpdateCall
     * Set call as live
     */
    goLive(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.goLiveRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * List Call Type
     */
    listCallTypesRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * List Call Type
     */
    listCallTypes(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listCallTypesRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Returns all available devices
     * List devices
     */
    listDevicesRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.userId !== undefined) {
                queryParameters['user_id'] = requestParameters.userId;
            }
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/devices`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Returns all available devices
     * List devices
     */
    listDevices(requestParameters = {}, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listDevicesRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists external storage
     * List external storage
     */
    listExternalStorageRaw(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Lists external storage
     * List external storage
     */
    listExternalStorage(initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listExternalStorageRaw(initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists recordings  Required permissions: - ListRecordings
     * List recordings
     */
    listRecordingsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listRecordings.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listRecordings.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/recordings`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Lists recordings  Required permissions: - ListRecordings
     * List recordings
     */
    listRecordings(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listRecordingsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Lists transcriptions  Required permissions: - ListTranscriptions
     * List transcriptions
     */
    listTranscriptionsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listTranscriptions.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listTranscriptions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/transcriptions`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Lists transcriptions  Required permissions: - ListTranscriptions
     * List transcriptions
     */
    listTranscriptions(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.listTranscriptionsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Mutes users in a call  Required permissions: - MuteUsers
     * Mute users
     */
    muteUsersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling muteUsers.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling muteUsers.');
            }
            if (requestParameters.videoMuteUsersRequest === null || requestParameters.videoMuteUsersRequest === undefined) {
                throw new RequiredError('videoMuteUsersRequest', 'Required parameter requestParameters.videoMuteUsersRequest was null or undefined when calling muteUsers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/mute_users`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoMuteUsersRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Mutes users in a call  Required permissions: - MuteUsers
     * Mute users
     */
    muteUsers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.muteUsersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Query call members with filter query  Required permissions: - ReadCall
     * Query call members
     */
    queryCallMembersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoQueryCallMembersRequest === null || requestParameters.videoQueryCallMembersRequest === undefined) {
                throw new RequiredError('videoQueryCallMembersRequest', 'Required parameter requestParameters.videoQueryCallMembersRequest was null or undefined when calling queryCallMembers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/members`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoQueryCallMembersRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Query call members with filter query  Required permissions: - ReadCall
     * Query call members
     */
    queryCallMembers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryCallMembersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Required permissions: - ReadCallStats
     * Query Call Stats
     */
    queryCallStatsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoQueryCallStatsRequest === null || requestParameters.videoQueryCallStatsRequest === undefined) {
                throw new RequiredError('videoQueryCallStatsRequest', 'Required parameter requestParameters.videoQueryCallStatsRequest was null or undefined when calling queryCallStats.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/stats`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoQueryCallStatsRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Required permissions: - ReadCallStats
     * Query Call Stats
     */
    queryCallStats(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryCallStatsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Query calls with filter query  Required permissions: - ReadCall
     * Query call
     */
    queryCallsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.videoQueryCallsRequest === null || requestParameters.videoQueryCallsRequest === undefined) {
                throw new RequiredError('videoQueryCallsRequest', 'Required parameter requestParameters.videoQueryCallsRequest was null or undefined when calling queryCalls.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calls`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoQueryCallsRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Query calls with filter query  Required permissions: - ReadCall
     * Query call
     */
    queryCalls(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.queryCallsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent
     * Send custom event
     */
    sendCallEventRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling sendCallEvent.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling sendCallEvent.');
            }
            if (requestParameters.videoSendCallEventRequest === null || requestParameters.videoSendCallEventRequest === undefined) {
                throw new RequiredError('videoSendCallEventRequest', 'Required parameter requestParameters.videoSendCallEventRequest was null or undefined when calling sendCallEvent.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/event`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoSendCallEventRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent
     * Send custom event
     */
    sendCallEvent(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.sendCallEventRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Starts HLS broadcasting  Required permissions: - StartBroadcasting
     * Start HLS broadcasting
     */
    startHLSBroadcastingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startHLSBroadcasting.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startHLSBroadcasting.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/start_broadcasting`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Starts HLS broadcasting  Required permissions: - StartBroadcasting
     * Start HLS broadcasting
     */
    startHLSBroadcasting(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.startHLSBroadcastingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording
     * Start recording
     */
    startRecordingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startRecording.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startRecording.');
            }
            if (requestParameters.videoStartRecordingRequest === null || requestParameters.videoStartRecordingRequest === undefined) {
                throw new RequiredError('videoStartRecordingRequest', 'Required parameter requestParameters.videoStartRecordingRequest was null or undefined when calling startRecording.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/start_recording`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoStartRecordingRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording
     * Start recording
     */
    startRecording(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.startRecordingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Starts transcription  Required permissions: - StartTranscription
     * Start transcription
     */
    startTranscriptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startTranscription.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startTranscription.');
            }
            if (requestParameters.videoStartTranscriptionRequest === null || requestParameters.videoStartTranscriptionRequest === undefined) {
                throw new RequiredError('videoStartTranscriptionRequest', 'Required parameter requestParameters.videoStartTranscriptionRequest was null or undefined when calling startTranscription.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/start_transcription`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoStartTranscriptionRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Starts transcription  Required permissions: - StartTranscription
     * Start transcription
     */
    startTranscription(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.startTranscriptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Stops HLS broadcasting  Required permissions: - StopBroadcasting
     * Stop HLS broadcasting
     */
    stopHLSBroadcastingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopHLSBroadcasting.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopHLSBroadcasting.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stop_broadcasting`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Stops HLS broadcasting  Required permissions: - StopBroadcasting
     * Stop HLS broadcasting
     */
    stopHLSBroadcasting(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.stopHLSBroadcastingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall
     * Set call as not live
     */
    stopLiveRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopLive.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopLive.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stop_live`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall
     * Set call as not live
     */
    stopLive(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.stopLiveRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording
     * Stop recording
     */
    stopRecordingRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopRecording.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopRecording.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stop_recording`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording
     * Stop recording
     */
    stopRecording(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.stopRecordingRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription
     * Stop transcription
     */
    stopTranscriptionRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopTranscription.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopTranscription.');
            }
            const queryParameters = {};
            const headerParameters = {};
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/stop_transcription`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription
     * Stop transcription
     */
    stopTranscription(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.stopTranscriptionRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser
     * Unblocks user on a call
     */
    unblockUserRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling unblockUser.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling unblockUser.');
            }
            if (requestParameters.videoUnblockUserRequest === null || requestParameters.videoUnblockUserRequest === undefined) {
                throw new RequiredError('videoUnblockUserRequest', 'Required parameter requestParameters.videoUnblockUserRequest was null or undefined when calling unblockUser.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/unblock`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUnblockUserRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser
     * Unblocks user on a call
     */
    unblockUser(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.unblockUserRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall
     * Update Call
     */
    updateCallRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCall.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCall.');
            }
            if (requestParameters.videoUpdateCallRequest === null || requestParameters.videoUpdateCallRequest === undefined) {
                throw new RequiredError('videoUpdateCallRequest', 'Required parameter requestParameters.videoUpdateCallRequest was null or undefined when calling updateCall.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'PATCH',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateCallRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.updated  Required permissions: - UpdateCall
     * Update Call
     */
    updateCall(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCallRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole
     * Update Call Member
     */
    updateCallMembersRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCallMembers.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCallMembers.');
            }
            if (requestParameters.videoUpdateCallMembersRequest === null || requestParameters.videoUpdateCallMembersRequest === undefined) {
                throw new RequiredError('videoUpdateCallMembersRequest', 'Required parameter requestParameters.videoUpdateCallMembersRequest was null or undefined when calling updateCallMembers.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/members`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateCallMembersRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole
     * Update Call Member
     */
    updateCallMembers(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCallMembersRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Update Call Type
     */
    updateCallTypeRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateCallType.');
            }
            if (requestParameters.videoUpdateCallTypeRequest === null || requestParameters.videoUpdateCallTypeRequest === undefined) {
                throw new RequiredError('videoUpdateCallTypeRequest', 'Required parameter requestParameters.videoUpdateCallTypeRequest was null or undefined when calling updateCallType.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/calltypes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateCallTypeRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Update Call Type
     */
    updateCallType(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateCallTypeRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     *
     * Update External Storage
     */
    updateExternalStorageRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.name === null || requestParameters.name === undefined) {
                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');
            }
            if (requestParameters.videoUpdateExternalStorageRequest === null || requestParameters.videoUpdateExternalStorageRequest === undefined) {
                throw new RequiredError('videoUpdateExternalStorageRequest', 'Required parameter requestParameters.videoUpdateExternalStorageRequest was null or undefined when calling updateExternalStorage.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/external_storage/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateExternalStorageRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     *
     * Update External Storage
     */
    updateExternalStorage(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateExternalStorageRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions
     * Update user permissions
     */
    updateUserPermissionsRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateUserPermissions.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateUserPermissions.');
            }
            if (requestParameters.videoUpdateUserPermissionsRequest === null || requestParameters.videoUpdateUserPermissionsRequest === undefined) {
                throw new RequiredError('videoUpdateUserPermissionsRequest', 'Required parameter requestParameters.videoUpdateUserPermissionsRequest was null or undefined when calling updateUserPermissions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/user_permissions`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUpdateUserPermissionsRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions
     * Update user permissions
     */
    updateUserPermissions(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.updateUserPermissionsRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Pins a track for all users in the call.  Required permissions: - PinCallTrack
     * Pin
     */
    videoPinRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoPin.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoPin.');
            }
            if (requestParameters.videoPinRequest === null || requestParameters.videoPinRequest === undefined) {
                throw new RequiredError('videoPinRequest', 'Required parameter requestParameters.videoPinRequest was null or undefined when calling videoPin.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/pin`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoPinRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Pins a track for all users in the call.  Required permissions: - PinCallTrack
     * Pin
     */
    videoPin(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.videoPinRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
    /**
     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack
     * Unpin
     */
    videoUnpinRaw(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.type === null || requestParameters.type === undefined) {
                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoUnpin.');
            }
            if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoUnpin.');
            }
            if (requestParameters.videoUnpinRequest === null || requestParameters.videoUnpinRequest === undefined) {
                throw new RequiredError('videoUnpinRequest', 'Required parameter requestParameters.videoUnpinRequest was null or undefined when calling videoUnpin.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Stream-Auth-Type"] = this.configuration.apiKey("Stream-Auth-Type"); // stream-auth-type authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                queryParameters["api_key"] = this.configuration.apiKey("api_key"); // api_key authentication
            }
            if (this.configuration && this.configuration.apiKey) {
                headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // JWT authentication
            }
            const response = yield this.request({
                path: `/video/call/{type}/{id}/unpin`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: requestParameters.videoUnpinRequest,
            }, initOverrides);
            return new JSONApiResponse(response);
        });
    }
    /**
     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack
     * Unpin
     */
    videoUnpin(requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.videoUnpinRaw(requestParameters, initOverrides);
            return yield response.value();
        });
    }
}

class StreamCall {
    constructor(streamClient, type, id) {
        this.streamClient = streamClient;
        this.type = type;
        this.id = id;
        this.blockUser = (videoBlockUserRequest) => {
            return this.apiClient.blockUser(Object.assign(Object.assign({}, this.baseRequest), { videoBlockUserRequest }));
        };
        this.endCall = () => {
            return this.apiClient.endCall(Object.assign({}, this.baseRequest));
        };
        this.get = (request) => {
            return this.apiClient.getCall(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest));
        };
        this.delete = (videoDeleteCallRequest) => {
            return this.apiClient.deleteCall(Object.assign(Object.assign({}, this.baseRequest), { videoDeleteCallRequest: videoDeleteCallRequest !== null && videoDeleteCallRequest !== void 0 ? videoDeleteCallRequest : null }));
        };
        this.getOrCreate = (videoGetOrCreateCallRequest) => {
            return this.apiClient.getOrCreateCall(Object.assign(Object.assign({}, this.baseRequest), { videoGetOrCreateCallRequest: videoGetOrCreateCallRequest !== null && videoGetOrCreateCallRequest !== void 0 ? videoGetOrCreateCallRequest : {} }));
        };
        this.getSessionStatistics = (request) => {
            return this.apiClient.getCallStats(Object.assign(Object.assign({}, this.baseRequest), request));
        };
        this.create = (getOrCreateCallRequest) => {
            return this.getOrCreate(getOrCreateCallRequest);
        };
        this.goLive = (videoGoLiveRequest) => {
            return this.apiClient.goLive(Object.assign(Object.assign({}, this.baseRequest), { videoGoLiveRequest: videoGoLiveRequest !== null && videoGoLiveRequest !== void 0 ? videoGoLiveRequest : {} }));
        };
        this.listRecordings = () => {
            return this.apiClient.listRecordings(Object.assign({}, this.baseRequest));
        };
        this.deleteRecording = (request) => {
            return this.apiClient.deleteRecording(Object.assign(Object.assign({}, this.baseRequest), request));
        };
        this.listTranscriptions = () => {
            return this.apiClient.listTranscriptions(Object.assign({}, this.baseRequest));
        };
        this.muteUsers = (videoMuteUsersRequest) => {
            return this.apiClient.muteUsers(Object.assign(Object.assign({}, this.baseRequest), { videoMuteUsersRequest }));
        };
        this.queryMembers = (request) => {
            return this.apiClient.queryCallMembers({
                videoQueryCallMembersRequest: Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest),
            });
        };
        this.sendCustomEvent = (videoSendCallEventRequest) => {
            return this.apiClient.sendCallEvent(Object.assign({ videoSendCallEventRequest }, this.baseRequest));
        };
        this.startHLSBroadcasting = () => {
            return this.apiClient.startHLSBroadcasting(Object.assign({}, this.baseRequest));
        };
        this.startRecording = (request) => {
            return this.apiClient.startRecording(Object.assign(Object.assign({}, this.baseRequest), { videoStartRecordingRequest: request !== null && request !== void 0 ? request : {} }));
        };
        this.startTranscription = (videoStartTranscriptionRequest = {}) => {
            return this.apiClient.startTranscription(Object.assign(Object.assign({}, this.baseRequest), { videoStartTranscriptionRequest }));
        };
        this.deleteTranscription = (request) => {
            return this.apiClient.deleteTranscription(Object.assign(Object.assign({}, this.baseRequest), request));
        };
        this.stopHLSBroadcasting = () => {
            return this.apiClient.stopHLSBroadcasting(Object.assign({}, this.baseRequest));
        };
        this.stopLive = () => {
            return this.apiClient.stopLive(Object.assign({}, this.baseRequest));
        };
        this.stopRecording = () => {
            return this.apiClient.stopRecording(Object.assign({}, this.baseRequest));
        };
        this.stopTranscription = () => {
            return this.apiClient.stopTranscription(Object.assign({}, this.baseRequest));
        };
        this.unblockUser = (videoUnblockUserRequest) => {
            return this.apiClient.unblockUser(Object.assign({ videoUnblockUserRequest }, this.baseRequest));
        };
        this.update = (videoUpdateCallRequest) => {
            return this.apiClient.updateCall(Object.assign({ videoUpdateCallRequest }, this.baseRequest));
        };
        this.updateCallMembers = (videoUpdateCallMembersRequest) => {
            return this.apiClient.updateCallMembers(Object.assign({ videoUpdateCallMembersRequest }, this.baseRequest));
        };
        this.updateUserPermissions = (videoUpdateUserPermissionsRequest) => {
            return this.apiClient.updateUserPermissions(Object.assign({ videoUpdateUserPermissionsRequest }, this.baseRequest));
        };
        this.pinVideo = (videoPinRequest) => {
            return this.apiClient.videoPin(Object.assign({ videoPinRequest }, this.baseRequest));
        };
        this.unpinVideo = (videoUnpinRequest) => {
            return this.apiClient.videoUnpin(Object.assign({ videoUnpinRequest }, this.baseRequest));
        };
        this.baseRequest = { id: this.id, type: this.type };
        const configuration = this.streamClient.getConfiguration('video');
        this.apiClient = new ProductvideoApi(configuration);
    }
    get cid() {
        return `${this.type}:${this.id}`;
    }
}

class StreamVideoClient {
    constructor(streamClient) {
        this.streamClient = streamClient;
        this.call = (type, id) => {
            return new StreamCall(this.streamClient, type, id);
        };
        this.queryCalls = (request) => {
            return this.apiClient.queryCalls({
                videoQueryCallsRequest: request !== null && request !== void 0 ? request : {},
            });
        };
        this.queryCallStatistics = (videoQueryCallStatsRequest) => {
            return this.apiClient.queryCallStats({
                videoQueryCallStatsRequest: videoQueryCallStatsRequest !== null && videoQueryCallStatsRequest !== void 0 ? videoQueryCallStatsRequest : {},
            });
        };
        this.createCallType = (videoCreateCallTypeRequest) => {
            return this.apiClient.createCallType({
                videoCreateCallTypeRequest,
            });
        };
        this.deleteCallType = (request) => {
            return this.apiClient.deleteCallType(request);
        };
        this.getCallType = (request) => {
            return this.apiClient.getCallType(request);
        };
        this.listCallTypes = () => {
            return this.apiClient.listCallTypes();
        };
        this.updateCallType = (name, videoUpdateCallTypeRequest) => {
            return this.apiClient.updateCallType({
                name,
                videoUpdateCallTypeRequest,
            });
        };
        this.listExternalStorages = () => {
            return this.apiClient.listExternalStorage();
        };
        this.createExternalStorage = (videoCreateExternalStorageRequest) => {
            return this.apiClient.createExternalStorage({
                videoCreateExternalStorageRequest,
            });
        };
        this.deleteExternalStorage = (request) => {
            return this.apiClient.deleteExternalStorage(request);
        };
        this.updateExternalStorage = (name, videoUpdateExternalStorageRequest) => {
            return this.apiClient.updateExternalStorage({
                name,
                videoUpdateExternalStorageRequest,
            });
        };
        this.checkExternalStorage = (request) => {
            return this.apiClient.checkExternalStorage(request);
        };
        const configuration = this.streamClient.getConfiguration('video');
        this.apiClient = new ProductvideoApi(configuration);
    }
}

function JWTUserToken(apiSecret, payload) {
    // make sure we return a clear error when jwt is shimmed (ie. browser build)
    if (jwt == null || jwt.sign == null) {
        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);
    }
    const opts = Object.assign({
        algorithm: 'HS256',
        noTimestamp: true,
    });
    if (payload.iat) {
        opts.noTimestamp = false;
    }
    return jwt.sign(payload, apiSecret, opts);
}
function JWTServerToken(apiSecret, jwtOptions = {}) {
    const payload = {
        server: true,
    };
    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);
    return jwt.sign(payload, apiSecret, opts);
}

class StreamClient {
    /**
     *
     * @param apiKey
     * @param secret
     * @param config can be a string, which will be interpreted as base path (deprecated), or a config object
     */
    constructor(apiKey, secret, config) {
        var _a;
        this.apiKey = apiKey;
        this.secret = secret;
        this.config = config;
        this.options = {};
        this.createDevice = (createDeviceRequest) => {
            return this.chatApi.createDevice({ createDeviceRequest });
        };
        this.deleteDevice = (requestParameters) => {
            return this.chatApi.deleteDevice(requestParameters);
        };
        this.listDevices = (requestParameters) => {
            return this.chatApi.listDevices(requestParameters);
        };
        this.listPushProviders = () => {
            return this.chatApi.listPushProviders();
        };
        this.deletePushProvider = (request) => {
            return this.chatApi.deletePushProvider(request);
        };
        this.upsertPushProvider = (request) => {
            return this.chatApi.upsertPushProvider({
                upsertPushProviderRequest: { push_provider: request },
            });
        };
        this.checkPush = (checkPushRequest) => {
            return this.chatApi.checkPush({ checkPushRequest });
        };
        this.createGuest = (createGuestRequest) => {
            return this.chatApi.createGuest({ createGuestRequest });
        };
        this.banUser = (banRequest) => {
            return this.chatApi.ban({ banRequest });
        };
        this.deactivateUser = (deactivateUserRequest) => {
            return this.chatApi.deactivateUser({
                deactivateUserRequest,
                userId: deactivateUserRequest.user_id,
            });
        };
        this.deactivateUsers = (deactivateUsersRequest) => {
            return this.chatApi.deactivateUsers({ deactivateUsersRequest });
        };
        this.deleteUsers = (deleteUsersRequest) => {
            return this.chatApi.deleteUsers({ deleteUsersRequest });
        };
        this.exportUser = (request) => {
            return this.chatApi.exportUser(request);
        };
        this.exportUsers = (exportUsersRequest) => {
            return this.chatApi.exportUsers({ exportUsersRequest });
        };
        this.flag = (flagRequest) => {
            return this.chatApi.flag({ flagRequest });
        };
        this.queryBannedUsers = (payload) => {
            return this.chatApi.queryBannedUsers({ payload });
        };
        this.queryUsers = (payload) => {
            return this.chatApi.queryUsers({ payload });
        };
        this.reactivateUser = (reactivateUserRequest) => {
            return this.chatApi.reactivateUser({
                reactivateUserRequest,
                userId: reactivateUserRequest.user_id,
            });
        };
        this.reactivateUsers = (reactivateUsersRequest) => {
            return this.chatApi.reactivateUsers({ reactivateUsersRequest });
        };
        this.restoreUsers = (restoreUsersRequest) => {
            return this.chatApi.restoreUsers({ restoreUsersRequest });
        };
        this.unbanUser = (request) => {
            return this.chatApi.unban(request);
        };
        this.upsertUsers = (updateUsersRequest) => {
            return this.chatApi.updateUsers({ updateUsersRequest });
        };
        this.updateUsersPartial = (request) => {
            return this.chatApi.updateUsersPartial({
                updateUsersPartialRequest: request,
            });
        };
        this.muteUser = (muteUserRequest) => {
            return this.chatApi.muteUser({ muteUserRequest });
        };
        this.unmuteUser = (unmuteUserRequest) => {
            return this.chatApi.unmuteUser({ unmuteUserRequest });
        };
        this.sendCustomEventToUser = (userId, event) => {
            return this.chatApi.sendUserCustomEvent({
                userId,
                sendUserCustomEventRequest: { event },
            });
        };
        this.createRole = (createRoleRequest) => {
            return this.chatApi.createRole({ createRoleRequest });
        };
        this.deleteRole = (request) => {
            return this.chatApi.deleteRole(request);
        };
        this.getPermission = (request) => {
            return this.chatApi.getPermission(request);
        };
        this.listPermissions = () => {
            return this.chatApi.listPermissions();
        };
        this.listRoles = () => {
            return this.chatApi.listRoles();
        };
        this.getAppSettings = () => {
            return this.chatApi.getApp();
        };
        this.updateAppSettings = (updateAppRequest) => {
            return this.chatApi.updateApp({ updateAppRequest });
        };
        this.getRateLimits = () => {
            return this.chatApi.getRateLimits();
        };
        this.getTaskStatus = (request) => {
            return this.chatApi.getTask(request);
        };
        this.verifyWebhook = (requestBody, xSignature) => {
            const key = Buffer.from(this.secret, 'utf8');
            const hash = crypto
                .createHmac('sha256', key)
                .update(requestBody)
                .digest('hex');
            try {
                return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(xSignature));
            }
            catch (err) {
                return false;
            }
        };
        this.blockUsers = (blockUsersRequest) => {
            return this.chatApi.blockUsers({ blockUsersRequest });
        };
        this.unblockUsers = (unblockUsersRequest) => {
            return this.chatApi.unblockUsers({ unblockUsersRequest });
        };
        this.getBlockedUsers = (request) => {
            return this.chatApi.getBlockedUsers(request);
        };
        this.getConfiguration = (product = 'chat') => {
            var _a;
            return new Configuration({
                apiKey: (name) => {
                    const mapping = {
                        'Stream-Auth-Type': 'jwt',
                        api_key: this.apiKey,
                        Authorization: this.token,
                    };
                    return mapping[name];
                },
                basePath: (_a = this.options.basePath) !== null && _a !== void 0 ? _a : (product === 'chat'
                    ? 'https://chat.stream-io-api.com'
                    : 'https://video.stream-io-api.com'),
                headers: {
                    'X-Stream-Client': 'stream-node-' + "0.3.0",
                },
                middleware: [
                    {
                        pre: (context) => {
                            context.init.headers = Object.assign(Object.assign({}, context.init.headers), { 'x-client-request-id': uuid.v4(), 'Accept-Encoding': 'gzip' });
                            return Promise.resolve(context);
                        },
                    },
                    {
                        // This should be the last post middleware because that will throw an error
                        // The Fetch API won't throw an error for HTTP error responses, which means the "onError" middleware won't be called so we need to throw error from "post" middleware
                        post: (context) => __awaiter(this, void 0, void 0, function* () {
                            if ((context.response && context.response.status < 200) ||
                                context.response.status >= 300) {
                                const response = new JSONApiResponse(context.response);
                                const value = (yield response.value());
                                throw new Error(`Stream error code ${value.code}: ${value.message}`);
                            }
                        }),
                    },
                    {
                        pre: (context) => {
                            context.init.signal = AbortSignal.timeout(this.options.timeout);
                            return Promise.resolve(context);
                        },
                        onError: (context) => {
                            const error = context.error;
                            if (error.name === 'AbortError' || error.name === 'TimeoutError') {
                                throw new FetchError(error, `The request was aborted due to to the ${this.options.timeout}ms timeout, you can set the timeout in the StreamClient constructor`);
                            }
                            return Promise.resolve(context.response);
                        },
                    },
                ],
                // https://github.com/OpenAPITools/openapi-generator/issues/13222
                queryParamsStringify: (params) => {
                    const newParams = [];
                    for (const k in params) {
                        const param = params[k];
                        if (Array.isArray(param)) {
                            newParams.push(`${k}=${encodeURIComponent(param.join(','))}`);
                        }
                        else if (typeof param === 'object') {
                            newParams.push(`${k}=${encodeURIComponent(JSON.stringify(param))}`);
                        }
                        else {
                            if (typeof param === 'string' ||
                                typeof param === 'number' ||
                                typeof param === 'boolean') {
                                newParams.push(`${k}=${encodeURIComponent(param)}`);
                            }
                        }
                    }
                    return newParams.join('&');
                },
            });
        };
        this.token = JWTServerToken(this.secret);
        if (typeof config === 'string') {
            this.options.basePath = config;
            this.options.timeout = StreamClient.DEFAULT_TIMEOUT;
        }
        else {
            if (config) {
                this.options = config;
            }
            this.options.timeout = (_a = config === null || config === void 0 ? void 0 : config.timeout) !== null && _a !== void 0 ? _a : StreamClient.DEFAULT_TIMEOUT;
        }
        this.video = new StreamVideoClient(this);
        this.chat = new StreamChatClient(this);
        const chatConfiguration = this.getConfiguration();
        /** @ts-expect-error */
        this.chatApi = new ProductchatApi(chatConfiguration);
    }
    /**
     *
     * @param userID
     * @param exp
     * @param iat deprecated, the default date will be set internally
     * @param call_cids this parameter is deprecated use `createCallToken` for call tokens
     * @returns
     */
    createToken(userID, exp = Math.round(Date.now() / 1000) + 60 * 60, iat = Math.floor((Date.now() - 1000) / 1000), call_cids) {
        const payload = {
            user_id: userID,
            exp,
            iat,
        };
        if (call_cids) {
            console.warn(`Use createCallToken method for creating call tokens, the "call_cids" param will be removed from the createToken method with version 0.2.0`);
            payload.call_cids = call_cids;
        }
        return JWTUserToken(this.secret, payload);
    }
    /**
     *
     * @param userID
     * @param call_cids
     * @param exp
     * @param iat this is deprecated, the current date will be set internally
     * @returns
     */
    createCallToken(userIdOrObject, call_cids, exp = Math.round(Date.now() / 1000) + 60 * 60, iat = Math.floor((Date.now() - 1000) / 1000)) {
        const payload = {
            exp,
            iat,
            call_cids,
            user_id: typeof userIdOrObject === 'string'
                ? userIdOrObject
                : userIdOrObject.user_id,
        };
        if (typeof userIdOrObject === 'object' && userIdOrObject.role) {
            payload.role = userIdOrObject.role;
        }
        return JWTUserToken(this.secret, payload);
    }
}
StreamClient.DEFAULT_TIMEOUT = 3000;

exports.APNConfigAuthTypeEnum = APNConfigAuthTypeEnum;
exports.AsyncModerationCallbackConfigModeEnum = AsyncModerationCallbackConfigModeEnum;
exports.AudioSettingsDefaultDeviceEnum = AudioSettingsDefaultDeviceEnum;
exports.BlockListOptionsBehaviorEnum = BlockListOptionsBehaviorEnum;
exports.ChannelConfigAutomodBehaviorEnum = ChannelConfigAutomodBehaviorEnum;
exports.ChannelConfigAutomodEnum = ChannelConfigAutomodEnum;
exports.ChannelConfigBlocklistBehaviorEnum = ChannelConfigBlocklistBehaviorEnum;
exports.ChannelConfigWithInfoAutomodBehaviorEnum = ChannelConfigWithInfoAutomodBehaviorEnum;
exports.ChannelConfigWithInfoAutomodEnum = ChannelConfigWithInfoAutomodEnum;
exports.ChannelConfigWithInfoBlocklistBehaviorEnum = ChannelConfigWithInfoBlocklistBehaviorEnum;
exports.ChannelTypeConfigAutomodBehaviorEnum = ChannelTypeConfigAutomodBehaviorEnum;
exports.ChannelTypeConfigAutomodEnum = ChannelTypeConfigAutomodEnum;
exports.ChannelTypeConfigBlocklistBehaviorEnum = ChannelTypeConfigBlocklistBehaviorEnum;
exports.CheckPushRequestPushProviderTypeEnum = CheckPushRequestPushProviderTypeEnum;
exports.CheckSNSResponseStatusEnum = CheckSNSResponseStatusEnum;
exports.CheckSQSResponseStatusEnum = CheckSQSResponseStatusEnum;
exports.ConfigDefaultRoleEnum = ConfigDefaultRoleEnum;
exports.CreateBlockListRequestTypeEnum = CreateBlockListRequestTypeEnum;
exports.CreateCallRequestTypeEnum = CreateCallRequestTypeEnum;
exports.CreateChannelTypeRequestAutomodBehaviorEnum = CreateChannelTypeRequestAutomodBehaviorEnum;
exports.CreateChannelTypeRequestAutomodEnum = CreateChannelTypeRequestAutomodEnum;
exports.CreateChannelTypeRequestBlocklistBehaviorEnum = CreateChannelTypeRequestBlocklistBehaviorEnum;
exports.CreateChannelTypeResponseAutomodBehaviorEnum = CreateChannelTypeResponseAutomodBehaviorEnum;
exports.CreateChannelTypeResponseAutomodEnum = CreateChannelTypeResponseAutomodEnum;
exports.CreateChannelTypeResponseBlocklistBehaviorEnum = CreateChannelTypeResponseBlocklistBehaviorEnum;
exports.CreateDeviceRequestPushProviderEnum = CreateDeviceRequestPushProviderEnum;
exports.CreateExternalStorageRequestStorageTypeEnum = CreateExternalStorageRequestStorageTypeEnum;
exports.CreateImportRequestModeEnum = CreateImportRequestModeEnum;
exports.CreatePollRequestVotingVisibilityEnum = CreatePollRequestVotingVisibilityEnum;
exports.DeleteUsersRequestCallsEnum = DeleteUsersRequestCallsEnum;
exports.DeleteUsersRequestConversationsEnum = DeleteUsersRequestConversationsEnum;
exports.DeleteUsersRequestMessagesEnum = DeleteUsersRequestMessagesEnum;
exports.DeleteUsersRequestUserEnum = DeleteUsersRequestUserEnum;
exports.DevicePushProviderEnum = DevicePushProviderEnum;
exports.ExternalStorageResponseTypeEnum = ExternalStorageResponseTypeEnum;
exports.ImageSizeCropEnum = ImageSizeCropEnum;
exports.ImageSizeResizeEnum = ImageSizeResizeEnum;
exports.LayoutSettingsNameEnum = LayoutSettingsNameEnum;
exports.MessageRequestTypeEnum = MessageRequestTypeEnum;
exports.MessageTypeEnum = MessageTypeEnum;
exports.NoiseCancellationSettingsModeEnum = NoiseCancellationSettingsModeEnum;
exports.PermissionLevelEnum = PermissionLevelEnum;
exports.PolicyRequestActionEnum = PolicyRequestActionEnum;
exports.PushConfigVersionEnum = PushConfigVersionEnum;
exports.StreamCall = StreamCall;
exports.StreamChannel = StreamChannel;
exports.StreamChatClient = StreamChatClient;
exports.StreamClient = StreamClient;
exports.StreamVideoClient = StreamVideoClient;
exports.TranscriptionSettingsModeEnum = TranscriptionSettingsModeEnum;
exports.TranslateMessageRequestLanguageEnum = TranslateMessageRequestLanguageEnum;
exports.UpdateAppRequestEnforceUniqueUsernamesEnum = UpdateAppRequestEnforceUniqueUsernamesEnum;
exports.UpdateAppRequestPermissionVersionEnum = UpdateAppRequestPermissionVersionEnum;
exports.UpdateAppRequestVideoProviderEnum = UpdateAppRequestVideoProviderEnum;
exports.UpdateChannelTypeRequestAutomodBehaviorEnum = UpdateChannelTypeRequestAutomodBehaviorEnum;
exports.UpdateChannelTypeRequestAutomodEnum = UpdateChannelTypeRequestAutomodEnum;
exports.UpdateChannelTypeRequestBlocklistBehaviorEnum = UpdateChannelTypeRequestBlocklistBehaviorEnum;
exports.UpdateChannelTypeResponseAutomodBehaviorEnum = UpdateChannelTypeResponseAutomodBehaviorEnum;
exports.UpdateChannelTypeResponseAutomodEnum = UpdateChannelTypeResponseAutomodEnum;
exports.UpdateChannelTypeResponseBlocklistBehaviorEnum = UpdateChannelTypeResponseBlocklistBehaviorEnum;
exports.UpdateExternalStorageRequestStorageTypeEnum = UpdateExternalStorageRequestStorageTypeEnum;
exports.UpdateExternalStorageResponseTypeEnum = UpdateExternalStorageResponseTypeEnum;
exports.UpdatePollRequestVotingVisibilityEnum = UpdatePollRequestVotingVisibilityEnum;
exports.VideoAudioSettingsRequestDefaultDeviceEnum = VideoAudioSettingsRequestDefaultDeviceEnum;
exports.VideoAudioSettingsResponseDefaultDeviceEnum = VideoAudioSettingsResponseDefaultDeviceEnum;
exports.VideoCreateDeviceRequestPushProviderEnum = VideoCreateDeviceRequestPushProviderEnum;
exports.VideoCreateExternalStorageRequestStorageTypeEnum = VideoCreateExternalStorageRequestStorageTypeEnum;
exports.VideoDevicePushProviderEnum = VideoDevicePushProviderEnum;
exports.VideoExternalStorageResponseTypeEnum = VideoExternalStorageResponseTypeEnum;
exports.VideoLayoutSettingsRequestNameEnum = VideoLayoutSettingsRequestNameEnum;
exports.VideoLayoutSettingsResponseNameEnum = VideoLayoutSettingsResponseNameEnum;
exports.VideoNoiseCancellationSettingsModeEnum = VideoNoiseCancellationSettingsModeEnum;
exports.VideoOwnCapability = VideoOwnCapability;
exports.VideoRecordSettingsRequestModeEnum = VideoRecordSettingsRequestModeEnum;
exports.VideoRecordSettingsRequestQualityEnum = VideoRecordSettingsRequestQualityEnum;
exports.VideoSettingsCameraFacingEnum = VideoSettingsCameraFacingEnum;
exports.VideoTranscriptionSettingsRequestModeEnum = VideoTranscriptionSettingsRequestModeEnum;
exports.VideoTranscriptionSettingsResponseModeEnum = VideoTranscriptionSettingsResponseModeEnum;
exports.VideoUpdateExternalStorageRequestStorageTypeEnum = VideoUpdateExternalStorageRequestStorageTypeEnum;
exports.VideoUpdateExternalStorageResponseTypeEnum = VideoUpdateExternalStorageResponseTypeEnum;
exports.VideoVideoSettingsRequestCameraFacingEnum = VideoVideoSettingsRequestCameraFacingEnum;
exports.VideoVideoSettingsResponseCameraFacingEnum = VideoVideoSettingsResponseCameraFacingEnum;
//# sourceMappingURL=index.cjs.js.map
