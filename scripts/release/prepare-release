#!/bin/bash

required_branch="develop-test"
release_branch="release-test"
### Ensure on develop branch
# Fetch the current Git branch
current_branch=$(git rev-parse --abbrev-ref HEAD)
if [ "$current_branch" != "$required_branch" ]; then
    echo "You are not on the '$required_branch' branch. Please switch to '$required_branch' to continue."
    exit 1
fi

echo "Move into ../../buildSrc/src/main/kotlin/io/getstream/video/android/"
cd ../../buildSrc/src/main/kotlin/io/getstream/video/android/ || exit
file_path="Configuration.kt"

# Function to extract version components
extract_version_components() {
    grep "const val $1" "$file_path" | awk -F"=" '{print $2}' | tr -d ' ;'
}

# Extracting the major, minor, and patch versions
majorVersion=$(extract_version_components "majorVersion")
minorVersion=$(extract_version_components "minorVersion")
patchVersion=$(extract_version_components "patchVersion")

# Automatically increment the patch version
let "patchVersion+=1"

# Combining them into a version string
extracted_version="$majorVersion.$minorVersion.$patchVersion"

validate_version_format() {
    if [[ $1 =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        return 0 # Valid format
    else
        return 1 # Invalid format
    fi
}

# Prompting the user for input with validation
while true; do
    read -p "Enter version (Press Enter to use $extracted_version or format X.Y.Z): " input_version
    # Use the extracted version if no input is provided
    if [[ -z "$input_version" ]]; then
        version=$extracted_version
        break
    elif validate_version_format "$input_version"; then
        version=$input_version
        break
    else
        echo "Invalid version format. Please use the format X.Y.Z (e.g., 1.2.3)."
    fi
done

# Use the extracted version if no input is provided
version=${input_version:-$extracted_version}

# Split the version into major, minor, and patch numbers
IFS='.' read -r input_majorVersion input_minorVersion input_patchVersion <<< "$version"

# Function to update version components in the file
update_version_in_file() {
    local component=$1
    local value=$2
    # For macOS compatibility, check if we need to use an empty string with '-i'
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/const val $component =.*/const val $component = $value/" "$file_path"
    else
        sed -i "s/const val $component =.*/const val $component = $value/" "$file_path"
    fi
}

# Updating the versions in the Kotlin file
update_version_in_file "majorVersion" "$input_majorVersion"
update_version_in_file "minorVersion" "$input_minorVersion"
update_version_in_file "patchVersion" "$input_patchVersion"

echo "Version updated to: $version"

# Define the new branch name based on the version
branch_name="release/$version"

# If logged in with gh
git config --global credential.helper

# Create and switch to the new branch
git checkout -b "$branch_name"
git add "$file_path"
git commit -m "Update version to: $version"
echo "Committed the version update to $file_path."

if ! command -v gh >/dev/null 2>&1; then
    echo "Install and login to 'gh' if you want to continue automatic deployment."
    echo "As next steps you need to manually commit than push the '$branch_name' and create a PR to '$required_branch'. Then proceed to merge $required_branch into $ and do a Release on Github"
    exit 1
else
    # Print authentication status just in case
    gh auth status
    # Use auth from gh
    git config --global credential.helper cache

    # Optionally if gh is installed, push the new branch to your remote repository
    git push -u origin "$branch_name"
    echo "Branch $branch_name created and pushed to remote."

    # Create the PR and get its number, using $required_branch as the base
    old_pr=$(gh pr list --state open --base "$required_branch" | grep "$branch_name" | awk '{print $1}')
    if [ -n "$old_pr" ]; then
      echo "There is already PR for this $version, closing it."
      pr_number=$(echo "$pr_link" | grep -o '[0-9]*$')
      gh pr close "$pr_number"
    fi
    # Create PR
    pr_link=$(gh pr create --title "Prepare release: $version" --body "Automatic release PR for version $version." --base "$required_branch" --head "$branch_name")
    # Check if a PR was created
    existing_pr=$(gh pr list --state open --base "$required_branch" | grep "$branch_name" | awk '{print $1}')
    if [ -n "$existing_pr" ]; then
       # PR was created
       pr_number=$(echo "$pr_link" | grep -o '[0-9]*$')
       echo "PR #$pr_number created: '$release_branch'->'$required_branch'"
       echo "Waiting for all checks to complete successfully (excluding any skipped checks)..."
       # Function to wait for all checks to succeed
       # Function to check and wait for PR checks to complete successfully.
       wait_for_checks_to_succeed() {
           # Initially, there may be no checks reported. We need to wait for them to start.
           started_checks=false
           while true; do
               checks_output=$(gh pr checks "$pr_number")

               # Count the total number of checks reported (including pending, success, failure)
               checks_total=$(echo "$checks_output" | grep -E 'Expected|✓|success|x|failure|pending' | wc -l)

               # If we haven't seen any checks yet, and still see zero, it's possible they haven't started.
               # We wait until at least one check is reported to proceed.
               if ! $started_checks && [ "$checks_total" -eq 0 ]; then
                   echo "Waiting for checks to start..."
                   sleep 30
                   continue
               fi

               started_checks=true  # Once we see checks, this is always true.

               # Count successful and pending checks
               checks_success=$(echo "$checks_output" | grep -E '✓|success' | wc -l)
               checks_pending=$(echo "$checks_output" | grep 'pending' | wc -l)

               echo -ne "\rChecks status: $checks_success successful, $checks_pending pending out of $checks_total total."

               if [ "$checks_pending" -eq 0 ] && [ "$checks_total" -gt 0 ]; then
                   if [ "$checks_success" -eq "$checks_total" ]; then
                       echo "All checks have successfully completed."
                       break
                   else
                       echo "Some checks have failed."
                       return 1  # Exit the loop and indicate failure.
                   fi
               else
                   sleep 30
               fi
           done
       }
       # Loop until all checks have completed successfully, ignoring skipped ones
       # Use the function to wait for checks to complete
       if wait_for_checks_to_succeed; then
          echo "All checks passed for PR #$pr_number."
          # Now, wait for the PR to be merged
          gh pr merge "$pr_number" --squash
          echo "Merge PR #$pr_number."
          pr_state=$(gh pr view "$pr_number" --json state --jq .state)
          while [ "$pr_state" != "MERGED" ]; do
              sleep 30 # Adjust sleep time as needed
              pr_state=$(gh pr view "$pr_number" --json state --jq .state)
              if [ "$pr_state" == "MERGED" ]; then
                  echo "PR #$pr_number has been successfully merged."
                  # Step 1: Switch to the required branch and pull the latest changes
                  git checkout "$required_branch"
                  git pull origin "$required_branch"
                  echo "Updated $required_branch with the latest changes."
                  git checkout $release_branch
                  git pull origin "$release_branch"
                  git merge "$required_branch" -m "Merging $required_branch into $release_branch"
                  echo "Merged $required_branch into $release_branch."
                  # Step 3: Push the updated main branch to the remote repository
                  git push origin "$release_branch"
                  echo "Pushed the updated '$release_branch' branch to the remote repository. Go to Github/Releases and Draft a new release with tag number $version. The target branch should be '$release_branch'"

                  break
              elif [ "$pr_state" == "CLOSED" ]; then
                  echo "PR #$pr_number was closed without being merged. Please check manually what happened"
                  exit 1
                  break
              else
                  echo "PR #$pr_number is not merged yet. Checking again in 30 seconds..."
              fi
          done
       else

           echo "Failed PR checks."
           exit 1
       fi
    else
        # PR was not created, exit
        echo "PR for '$branch_name' into '$required_branch'. Failed to create."
        exit 1
    fi
fi




