syntax = "proto3";

package stream.video.coordinator.event_v1;

import "validate/validate.proto";
import "video/coordinator/call_v1/call.proto";

option go_package = "event_v1";
option java_multiple_files = true;
option java_outer_classname = "EventV1";
option csharp_namespace = "Stream.Video.v1.Coordinator";

message RecordingStarted {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message RecordingStopped {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message UserUpdated {
  string user_id = 1 [(validate.rules).string.min_len = 1];
}

message BroadcastStarted {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message BroadcastEnded {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message CallMembersCreated {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
  bool ringing = 3;
}

message CallMembersUpdated {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message CallMembersDeleted {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message CallCreated {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
  bool ringing = 3;
}

message CallUpdated {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message CallEnded {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message CallDeleted {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
}

message CallAccepted {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
  string sender_user_id = 3 [(validate.rules).string.min_len = 1];
}

message CallRejected {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
  string sender_user_id = 3 [(validate.rules).string.min_len = 1];
}

message CallCancelled {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
  string sender_user_id = 3 [(validate.rules).string.min_len = 1];
}

// A custom event type
message CallCustom {
  call_v1.Call call = 1 [(validate.rules).message.required = true];
  call_v1.CallDetails call_details = 2 [(validate.rules).message.required = true];
  string sender_user_id = 3 [(validate.rules).string.min_len = 1];
  // The type of the event
  string type = 4 [(validate.rules).string.min_len = 1];
  // The data in the event
  bytes data_json = 5;
}

// Events
// * mute: when someone, or multiple people are muted
// * unmute: when someone, or multiple people are unmuted
// * broadcast.preferences: request from the SFU to the client to provide a different list of uploads
// * security.updated: share screen, chat, rename, unmute, start video, hide profile pictures
// * settings: multiple people can share, 1 person can share
// * request: screenshare, recording, unmute
// * room.created
// * room.updated
// * sfu.switch (actually this can be handled using the webrtc connection, but that seems less reliable)
// * network.quality
