syntax = "proto3";

package stream.video.sfu.event;

import "video/sfu/models/models.proto";

option go_package = "github.com/GetStream/protocol/protobuf/video/sfu/event";
option java_multiple_files = true;
option java_outer_classname = "SfuEventsV1";
option csharp_namespace = "Stream.Video.v1.Sfu";

// SFUEvent is a message that is sent from the SFU to the client.
message SfuEvent {
  oneof event_payload {
    SubscriberOffer subscriber_offer = 1;
    PublisherAnswer publisher_answer = 2;
    ConnectionQualityChanged connection_quality_changed = 3;
    AudioLevelChanged audio_level_changed = 4;
    models.ICETrickle ice_trickle = 5;
    ChangePublishQuality change_publish_quality = 6;
    ParticipantJoined participant_joined = 10;
    ParticipantLeft participant_left = 11;
    DominantSpeakerChanged dominant_speaker_changed = 12;
    JoinResponse join_response = 13;
    HealthCheckResponse health_check_response = 14;
    TrackPublished track_published = 16;
    TrackUnpublished track_unpublished = 17;
    Error error = 18;
    CallGrantsUpdated call_grants_updated = 19;
  }
}


message Error{
  models.Error error = 4;
}

message ICETrickle {
  models.PeerType peer_type = 1;
  string ice_candidate = 2;
}


// SfuRequest is a message that is sent from the client to the SFU.
message SfuRequest {
  oneof request_payload {
    JoinRequest join_request = 1;
    HealthCheckRequest health_check_request = 2;
  }
}

message HealthCheckRequest {
}

message HealthCheckResponse {
  uint32 participant_count = 1;
}

message TrackPublished {
  string user_id = 1;
  string session_id = 2;
  models.TrackType type = 3;

  // Participant information here is included as an optimisation
  // for large calls where broadcasting on every participant join
  // is expensive. You should **NOT** assume that this will always
  // be available though you can use it to update the participant
  // list when it is there.
  models.Participant participant = 4;
}

message TrackUnpublished {
  string user_id = 1;
  string session_id = 2;
  models.TrackType type = 3;
  models.TrackUnpublishReason cause = 4;

  // Participant information here is included as an optimisation
  // for large calls where broadcasting on every participant join
  // is expensive. You should **NOT** assume that this will always
  // be available though you can use it to update the participant
  // list when it is there.
  models.Participant participant = 5;
}

message JoinRequest {
  string token = 1;
  string session_id = 2;
  // dumb SDP that allow us to extract subscriber's decode codecs
  string subscriber_sdp = 3;
  models.ClientDetails client_details = 4;
  // TODO: we should know if this is going to be
  // - publishing and subscribing, or just subscribing for future routing
}

message JoinResponse {
  // TODO: include full list of participants with track and audio info
  models.CallState call_state = 1;
  uint32 participant_count = 2;
}

// ParticipantJoined is fired when a user joins a call
message ParticipantJoined {
  string call_cid = 1;
  models.Participant participant = 2;
}

// ParticipantJoined is fired when a user leaves a call
message ParticipantLeft {
  string call_cid = 1;
  models.Participant participant = 2;
}

// SubscriberOffer is sent when the SFU adds tracks to a subscription
message SubscriberOffer {
  bool ice_restart = 1;
  string sdp = 2;
}

message PublisherAnswer {
  string sdp = 1;
}

// ConnectionQuality is sent to inform about connection quality changes
// eg. thierry's connection is not good -> render a red icon Zoom style
message ConnectionQualityChanged {
  repeated ConnectionQualityInfo connection_quality_updates = 1;
}

message ConnectionQualityInfo {
  string user_id = 1;
  string session_id = 2;
  models.ConnectionQuality connection_quality = 3;
}

// DominantSpeakerChanged is sent by the SFU to notify when there is a new dominant speaker in the call
message DominantSpeakerChanged {
  string user_id = 1;
  string session_id = 2;
}

message AudioLevel{
  string user_id = 1;
  string session_id = 2;
  // 0.0 means complete silence, 1.0 loudest
  float level = 3;
  bool is_speaking = 4;
}

// AudioLevelChanged is sent by the SFU to notify about audio levels by user
message AudioLevelChanged {
  repeated AudioLevel audio_levels = 1;
}

message AudioMediaRequest {
  int32 channel_count = 1;
}

message AudioSender {
  AudioMediaRequest media_request = 1;
  models.Codec codec = 2;
}

message VideoMediaRequest {
  int32 ideal_height = 1;
  int32 ideal_width = 2;
  int32 ideal_frame_rate = 3;

}


message VideoLayerSetting {
  string name = 1;
  bool active = 2;
  int32 max_bitrate = 3;
  float scale_resolution_down_by = 4;
  enum Priority {
    PRIORITY_HIGH_UNSPECIFIED = 0;
    PRIORITY_LOW = 1;
    PRIORITY_MEDIUM = 2;
    PRIORITY_VERY_LOW = 3;
  }
  Priority priority = 5;
  models.Codec codec = 6;
}

message VideoSender {
  VideoMediaRequest media_request = 1;
  models.Codec codec = 2;
  repeated VideoLayerSetting layers = 3;
}

// sent to users when they need to change the quality of their video
message ChangePublishQuality {
  repeated AudioSender audio_senders = 1;
  repeated VideoSender video_senders = 2;
}

// CallGrants is sent to users when there is a change in the call permissions
// to publish audio, video or share the screen for a user or a role. This is
// idempotent and can be sent at any time. Only the current_grants in the latest
// message should be considered. In other words, this is not dependent on any
// other message (including previous call_grants_updated message)
//
// When this message is received, the client (say, React component) should mute
// the tracks which are not allowed anymore. For example, if the message has
// grants {audio:true, video:false} while the user is publishing video, then the
// client component should mute the video track and gray out the video button.
// This way, the user will not be able to publish video until the permissions
// are granted again. Also, muting the track on the client side will prevent
// the SFU from receiving the video track and will save bandwidth.
//
// In simple words, this is exactly the same as muting a track on the client.
// Here, instead of the user instructing the client, SFU would be doing it.
message CallGrantsUpdated {
  models.CallGrants current_grants = 1;
  string message = 2;
}