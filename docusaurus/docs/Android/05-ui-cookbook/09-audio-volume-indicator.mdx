---
title: Audio Volume Indicator
description: Audio Volume Indicator
---

Issues:
* No way to swap the participant card

The audio indicator gives you a visual feedback when a user is speaking.
To understand who's speaking we provide call.state.dominantSpeaker and call.state.activeSpeakers.
On the participant you can observe participant.speaking, participant.dominantSpeaker and participant.audioLevel

This example shows how to render a visual UI indicator that changes based on the audio level.

First let's create some fake audio data for the preview and create the preview

```kotlin
fun fakeAudioState(): StateFlow<List<Float>> {
    val audioFlow = flow {
        val audioLevels = listOf(0f,0f,0f,0f,0f).toMutableList()
        while (true) {
            val newValue = RandomKotlin.nextFloat()
            audioLevels.removeAt(0)
            audioLevels.add(newValue)
            emit(audioLevels.toList())
            delay(300)
        }
    }
    return audioFlow.stateIn(
        scope = CoroutineScope(Dispatchers.Default),
        started = SharingStarted.Eagerly,
        initialValue = listOf(0f, 0f, 0f, 0f, 0f)
    )
}

@Preview(showBackground = true)
@Composable
fun AudioPreview() {
    val audioLevels = fakeAudioState().collectAsState()
    MyApplicationTheme {
        //Greeting("Android")
        AudioVolumeIndicator(audioLevels)
    }
}
```

Next here's a little custom audio visualization


```kotlin
@Composable
fun AudioVolumeIndicator(audioState: State<List<Float>>) {
    // based on this fun blogpost: https://proandroiddev.com/jetpack-compose-tutorial-replicating-dribbble-audio-app-part-1-513ac91c02e3
    val infiniteAnimation = rememberInfiniteTransition()
    val animations = mutableListOf<State<Float>>()
    val audioLevels = audioState.value

    repeat(5) {
        val durationMillis = RandomKotlin.nextInt(500, 1000)
        animations += infiniteAnimation.animateFloat(
            initialValue = 0f,
            targetValue = 1f,
            animationSpec = infiniteRepeatable(
                animation = tween(durationMillis),
                repeatMode = RepeatMode.Reverse,
            )
        )
    }


    Canvas(modifier = Modifier.fillMaxSize()) {
        val canvasCenterY = 0
        var startOffset = 0f
        val barWidthFloat = 10f
        val barMinHeight = 0f
        val barMaxHeight = 150f
        val gapWidthFloat = 1f

        repeat(5) { index ->
            val currentSize = animations[index % animations.size].value
            var barHeightPercent = audioLevels[index] + currentSize
            if (barHeightPercent > 1.0f) {
                val diff = barHeightPercent - 1.0f
                barHeightPercent = 1.0f - diff
            }
            val barHeight = barMinHeight + (barMaxHeight - barMinHeight) * barHeightPercent
            drawLine(
                color = Color(0xFF9CCC65),
                start = Offset(startOffset, canvasCenterY - barHeight / 2),
                end = Offset(startOffset, canvasCenterY + barHeight / 2),
                strokeWidth = barWidthFloat,
                cap = StrokeCap.Round,
            )
            startOffset += barWidthFloat + gapWidthFloat
        }
    }
}
```

And here's how you can update the participant card to use this UI

```kotlin
TODO
```

The end result looks like this:

