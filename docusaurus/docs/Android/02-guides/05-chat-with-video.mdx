## Building Chat Apps With Video Support

One of the most common chat app use cases is having a chat feature in your app that allows users to engage in audio and video communication. This direct integration allows for simple transition between text and images to more complex media.

Stream supports this use case, out-of-the-box. In this guide, you'll walk through all the steps required to integrate our Chat and Video Android SDKs into a cohesive whole. You'll cover the following:

* Adding Stream dependencies.
* Creating Stream clients.
* Authenticating Chat and Video users.
* Building custom Call attachments and "Start Call" UI.

By the end of this guide, your app will look like this:

![payner](https://user-images.githubusercontent.com/17215808/211816425-bcec37cb-5956-4a5b-be40-fdc76b092947.png)

You'll have the ability to create messaging conversations, in which you can start calls as a custom attachment. Anyone in the chat will then be notified accordingly and can join the call.

Let's see how to implement this.

## Creating the project

The easiest way to get a project working is using one of our [Starter Kits](https://github.com/GetStream/stream-video-android/tree/main/examples/chat-with-video). Within the `chat-with-video` directory, open `chat-with-video-starter-kit` in Android studio.

> **Note**: Within the `chat-with-video` parent, there is a `chat-with-video-final` project that contains the final code for this guide. You can skip the starter kit and open that project instead if you want to see the finished solution.

Let the project sync. It should have all the dependencies required for you to finish this guide. Some of the notable dependencies are the following:

```groovy
dependencies {
    implementation(project(":stream-video-android-compose")) // TODO this should be a published dependency too

    // ...
    
    // Stream Chat
    implementation(Dependencies.streamChatCompose)
    implementation(Dependencies.streamChatOffline)
    implementation(Dependencies.streamChatState)
    implementation(Dependencies.streamChatUiUtils)
}
```

You'll be integrating two SDKs - Video and Chat. There is only one Video dependency right now, `stream-video-android-compose`, used to gain access to Jetpack Compose components and the low level client of the Video project.

For chat, you have a few dependencies:
* `streamChatCompose`: Similar to Video, gives access to Jetpack Components for Chat.
* `streamChatOffline`: Used to integrate offline support in Chat.
* `streamChatState`: Used to gain access to various state and its plugins for Chat.
* `streamChatUiUtils`: Helper functionality to render custom UI or format data.

The project already has a few screens set up for you with TODOs that you'll fill in later. Run the project and you should see the Login screen, followed by a blank Home screen after you select a user.

| Login Screen | Home Screen |
| ------------ | ----------- |
| ![login_screen](https://user-images.githubusercontent.com/17215808/212090608-a8662a31-7a1e-47af-91a2-578808c15324.png) | ![home_screen](https://user-images.githubusercontent.com/17215808/212090715-e5b51bb8-6215-42a0-92a3-696f21a79c4b.png) |

The pre-baked code contains all the logic that is not related to Stream, so that you can focus solely on integrating our two SDKs. We recommend exploring the project to learn how to navigate it and what each part of the predefined code does. Some of the notable functionality in the starter kit contains:

* Application class as an entry point for initializing our SDK.
* Fake user providers, with Chat and Video tokens prepared.
* Login, Home, Channels and Messages Activities for a default messaging app navigation. Most of these are empty for now, you'll fill them in.
* CallActivity and CallService placeholders. You'll use these to integrate the Video SDK.

Now that you have an overview of the starter project, let's start integrating the SDKs.

## Integrating the Chat SDK

The first step of integrating our [Stream Chat SDK](https://getstream.io/chat/docs/sdk/android/basics/getting-started/) is initializing the `ChatClient`. You'll do that in the `Application` class, as it's recommended to initialize the client as soon as your app is launched. On top of that, you'll have to log in a user, to fetch their information and conversations.

### Creating the Client

Open the `ChatWithVideoApp` file and replace the `chatClient` initialization with the following:

```kotlin
val chatClient: ChatClient by lazy {
    val offlinePlugin = StreamOfflinePluginFactory(this) // 1

    val statePluginFactory = StreamStatePluginFactory( // 2
        config = StatePluginConfig(
            backgroundSyncEnabled = true,
            userPresence = true,
        ),
        appContext = this
    )

    // 3
    val logLevel = if (BuildConfig.DEBUG) ChatLogLevel.ALL else ChatLogLevel.NOTHING

  	// 4
    ChatClient.Builder("tp8sef43xcpc", this)
        .withPlugins(offlinePlugin, statePluginFactory)
        .logLevel(logLevel)
        .uploadAttachmentsNetworkType(UploadAttachmentsNetworkType.NOT_ROAMING)
        .build()
}
```

There are a few parts to this initialization:

1. You create the `StreamOfflinePluginFactory` that's used to provide offline support to the `ChatClient`. This helps users browse cached channels and messages, even if their network connection is missing.
2. Following that, you set up a `StreamStatePluginFactory` which builds on top of the offline support, to provide background data sync as well as user online presence data. This is used to enrich the UI with online indicators.
3. To help you debug, you can provide a `ChatLogLevel`, which will print information about the API calls and data in the SDK.
4. Once you're ready, you initialize the `ChatClient`. You pass in the `API_KEY`, the `Context` and the rest of the components. You can pass in the key for your environment, but in this example we'll use a predefined environment instead.

With this client initialization, you can proceed to log in a user when you choose them on the Login screen.

### Logging in a User

Open `LoginActivity.kt` and replace `logInToChat` with the following:

```kotlin
private fun logInToChat(user: User) {
    val userLogin = io.getstream.chat.android.client.models.User( // 1
        id = user.id,
        name = user.name,
        image = user.imageUrl ?: ""
    )

    chatWithVideoApp.chatClient.connectUser( // 2
        user = userLogin,
        token = user.extraData["chatToken"] as String
    ).enqueue()
}
```

On the Login screen, when you select a user, you call `logInToChat`. This lets you set up the user for both Chat and Video SDK. In this case, you're doing the following:

1. You create a `User` object that holds the important information, such as the user ID, name and their image.
2. You pass in the `user` to `chatClient.connectUser()`. Aside from that, you provide the `ChatClient` with the user token, that's stored in the `extraData` map of properties. This will initialize the Chat SDK with the provided user and you can proceed to fetch their `Channel`s, `Message`s and more.

To finish up, you can add the logging out counterpart, by going back to `ChatWithVideoApp` and adding the following code to `logOut()`:

```kotlin
fun logOut() {
    val preferences = UserCredentialsManager.initialize(this)

    // TODO log out of clients
    chatClient.disconnect(true).enqueue() // here
    preferences.clear()
}
```

Using `chatClient.disconnect(flushPersistence = true)`, you prepare a call to disconnect from the SDK and flush any cache. Our functions are wrapped as asynchronous call constructs, so calling `enqueue()` is necessary to start the operation.

With all this, you'll be able to log in and log out any user from our predefined data set. The next step is to display their conversations.

### Implementing ChannelsActivity

There isn't much to the `ChannelsActivity` - it'll show a list of `Channel`s the user is a member of and let them open those `Channel`s. It'll also feature a custom header to allow the user to log out at will.

Most of the navigation functionality, like opening a `Channel` and logging out is already there, you just need to use our Compose UI Components to implement the UI.

Open `ChannelsActivity.kt`. Add the following code, to initialize the `ChannelListViewModel`, that'll help you load, fetch and display the required data:

```kotlin
private val factory by lazy { // 1
    ChannelViewModelFactory(
        chatClient = chatWithVideoApp.chatClient,
        querySort = QuerySortByField.descByName("last_updated"), // 2
        filters = null // 3
    )
}

private val channelListViewModel by viewModels<ChannelListViewModel> { factory } // 4

```

While this is a simple piece of code, there are a few steps to analyze:

1. Using `lazy` delegates, you can initialize the `ChannelViewModelFactory` used to build the `ViewModel`, without necessarily blocking any other initialization. The code will be called once the UI is ready to be rendered.
2. The factory requires a few pieces of data. It requires the `ChatClient` instance to communicate with the API, a `querySort` to define the order of the `Channel`s and `filters` to specify which `Channel`s we want to fetch.
3. The `querySort` is the default, sorted by the `last_updated` message, while passing in `null` filters dictates the default filter set, which only query for `Channel`s the current user is a member of. You can specify custom `filters` if you want to change this behavior.
4. Finally, using the `factory`, you can create a `ChannelListViewModel` through the `viewModels` delegate.

> **Note**: If you don't need any customization options and just want the default UI and behavior for browsing `Channel`s, you can simply use the `ChannelsScreen` as [per our documentation](https://getstream.io/chat/docs/sdk/android/compose/channel-components/channels-screen/). 

With the `ViewModel` ready, add the following code to the `setContent` block within `onCreate()`. Specifically, you'll add a header which will allow the user to log out and a component that shows a list of channels and lets you open the `MessagesActivity`.

Add the following code to the `Column` within `setContent()`:

```kotlin
val user by channelListViewModel.user.collectAsState() // 1

ChannelListHeader(
    modifier = Modifier.fillMaxWidth(),
    title = "Chat with Video Sample",
    currentUser = user,
    trailingContent = { // 2
        IconButton(
            onClick = { logOut() },
            content = {
                Icon(
                    imageVector = Icons.Default.Logout,
                    contentDescription = null,
                    tint = ChatTheme.colors.errorAccent
                )
            }
        )
    }
)

ChannelList(
    modifier = Modifier.fillMaxSize(),
    viewModel = channelListViewModel,
    onChannelLongClick = {},
    onChannelClick = { channel -> // 3
        openMessages(channel)
    }
)
```

There are only a few lines of code here that let you set up an entire screen and lots of functionality:

1. You fetch the current user from the `channelListViewModel` using `collectAsState()`. This is a Jetpack Compose helper that tranforms a `Flow` into `State` that Compose can render and react to.
2. Using that user and a few other parameters, you call `ChannelListHeader`. This is a simple component that displays a `title` and allows for a few handlers and customizable slot APIs. In this case, you override the `trailingContent` to show a button used to log out the user from the app.
3. Finally, using the `channelListViewModel`, you render a `ChannelList`, which shows a list of `Channel`s. Overriding `onChannelClick`, lets you set up functionality when a user selects any `Channel`. In your case, you call `openMessages()`.

Build and run the app and you should be able to log in or out with a user, as well as see and open the `Channel`s they're a part of.

![Screenshot_1673592655](https://user-images.githubusercontent.com/17215808/212255922-2fb8ba0c-e14c-4d13-9791-a7c6234aa0c9.png)

The next step to integrating the Chat SDK to replicate a chat-first-app which allows video calls, is to display the selected conversations and integrate custom attachments that render created calls.

### Adding Messaging Functionality

### Supporting Custom Attachments

## Integrating the Video SDK



### Initializing StreamVideo



### Logging in a User



### Connecting CallActivity & CallService



