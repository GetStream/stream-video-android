---
title: Livestream Tutorial
description: How to build a livestream experience using Stream's video SDKs
---

:::danger

This tutorial isn't ready yet
:::

## Livestream Tutorial

In this tutorial we'll quickly build a low-latency livestreaming experience similar to Twitch.

* We'll use ultra low latency streaming in this tutorial. Alternatively you can also broadcast to HLS
* The livestream will run on Stream's Edge network of servers around the world
* This architecture allows you to scale to millions of viewers
* To publish the livestream you can use either RTMPs (which is supported by OBS and pretty much all streaming software) or you can publish from your phone

Time to get started, if you have any questions or feedback be sure to let us know via the feedback button.

### Step 1 - Create a new project in android studio

Note that this tutorial was written using Android Studio Flamingo.
Setup steps can vary slightly across Android Studio versions so if you run into trouble be sure to use the latest version of Android Studio.

1. Create a new project
2. Select Phone & Template -> **empty activity**
3. Name your project **Livestream**.

### Step 2 - Install the SDK & Setup the client

**Add the compose SDK** to your app's `build.gradle` file found in app/build.gradle
If you're new to android note that there are 2 build.gradle files, you want to open the one in the app folder.

```groovy
dependencies {
    implementation "io.getstream:stream-video-android-compose:$stream_version"
}
```

### Step 3 - Publish from your phone

The following code shows how to publish from your phone's camera to the call.
Livestreams by default will start in the backstage mode.
The call works, you can join with your fellow call hosts, but participants aren't allowed to join yet.
You can call call.goLive() to start your livestream.

Let's open MainActivity.kt and replace it with:

```kotlin
val call = client.call("livestream", "id-here")
call.join()
call.camera.enable()
call.camera.flip() // if you want to flip the camera

call.goLive()

```

Now when you press live your video will be transmitted. You can confirm it by visiting
and connecting on this webpage. TODO

### Step 3A - Viewing a livestream (Webrtc)

The client setup for someone watching the call is quite similar.
You can join as an anonymous, guest or regular user.




```kotlin
```

```kotlin
val call = client.call("livestream", "id-here")
call.join()

setContent {
    VideoTheme {
        Livestream(call)
    }
}
```

- Muting the audio output of the livestream

### Step 3B - Viewing a livestream (HLS)

Alternatively you can use HLS to view the running call. This means the latency will be higher (typically an extra 10 seconds).
The benefit is that HLS buffers better for viewers.

### Step 4 - Recording a call

The last piece of the puzzle is recording your livestream.

### Other notes

- Anonymous users
- Picture in picture
- Reactions
- Recording options
- Broadcasting & HLS player
- Maybe remove RTMP in and out
- Participant count, how long it's running
- HLS webplayer on web

### Conclusion

That's it! You've built a low latency livestreaming experience using Stream's video SDKs.

