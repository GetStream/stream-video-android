---
title: Audio Room Tutorial
description: How to build an audio room using Stream's video SDKs
---

## Audio Room Tutorial

This tutorial will teach you how to build an audio room experience like Twitter Spaces or Clubhouse.

* Backstage mode. You can start the call with your co-hosts and chat a bit before going live
* Calls run on Stream's global edge network for optimal latency and scalability
* There is no cap to how many listeners you can have in a room
* Listeners can raise their hand, and be invited to speak by the host
* Audio tracks are send multiple times for optimal reliability

Time to get started

### Step 1 - Create a new project in android studio

Note that this tutorial was written using Android Studio Flamingo.
Setup steps can vary slightly across Android Studio versions so if you run into trouble be sure to use the latest version of Android Studio.

* Create a new project
* Select "empty activity"
* Name your project "AudioRoom"

### Step 2 - Install the SDK & Setup the client

** Add the compose SDK ** to your app's build.gradle file found in app/build.gradle
If you're new to android note that there are 2 build.gradle files, you want to open the one in the app folder.

```groovy
dependencies {
    implementation "io.getstream:stream-video-android-compose:$stream_version"
}
```

### Step 3 - Create & Join a call

Open up `MainActivity.kt` and add the following code to the onCreate method

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // create a user.
        val user = User(
            id = "tutorial@getstream.io", // any string
            name = "Tutorial", // name and image are used in the UI
            role = "admin" // user roles are important for an audio room
        )

        // for a production app we recommend adding the client to your Application class or di module.
        val client = StreamVideoBuilder(
             context = applicationContext,
             apiKey = "hd8szvscpxvd", // demo API key
             geo = GEO.GlobalEdgeNetwork,
             user = user,
             token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoidHV0b3JpYWxAZ2V0c3RyZWFtLmlvIiwiaXNzIjoicHJvbnRvIiwic3ViIjoidXNlci90dXRvcmlhbEBnZXRzdHJlYW0uaW8iLCJpYXQiOjE2ODYwNDAwOTUsImV4cCI6MTY4NjA1MDkwMH0.9m1wNAsn6UZHKu0i4_EWWw-sTBnbgDcV85Nmmbh7FNM",
        ).build()

        // join a call, which type is `audio_room` and id is `123`.
        val call = client.call("audio_room", "123")
        lifecycleScope.launch {
            call.join(create = true)
        }

        setContent {
            VideoTheme {
                val participants = call.state.participants.collectAsState()
                val connection = call.state.connection.collectAsState()
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = VideoTheme.colors.appBackground
                ) {
                    if (connection.value != RealtimeConnection.Connected) {
                        Text("loading...")
                    } else {
                        Text("Call ${call.id} has ${participants.value.size} participants", fontSize = 30.sp,  color = Color.Blue)
                    }
                }
            }
        }
    }
}
```

By default calls of type "audio_room" start with backstage mode enabled.
Admins and moderators can join the call. Regular users can only join the call when you go live.
This gives an opportunity to setup the audio/video etc before inviting people in.

### Step 4 - Adding audio room UI elements

In this next step we'll add:

* Room title, room description
* A list of participants
* An indicator for who's speaking

Let's create a component for the active speaker and the list of participants.

```kotlin
@Composable
fun DominantSpeaker(participant : ParticipantState?) {
    val user = participant?.user?.collectAsState()?.value
    Text("${user?.name} - ${user?.role}")
}

@Composable
fun ParticipantAvatar(participant : ParticipantState?) {
    val user = participant?.user?.collectAsState()?.value
    Text("${user?.name} - ${user?.role}")
}
```

Next we'll create a little audio room UI


```kotlin
setContent {
    VideoTheme {
        val custom = call.state.custom.collectAsState().value
        val title = custom["title"]
        val description = custom["description"]
        val participants = call.state.participants.collectAsState().value
        val dominantSpeaker = call.state.dominantSpeaker.collectAsState().value
        val otherParticipants = call.state.sortedParticipants.collectAsState().value.filter { it != dominantSpeaker }
        val audioLevel = dominantSpeaker?.audioLevel?.collectAsState()?.value ?: 0f
        val backstage = call.state.backstage.collectAsState().value

        val color1 = Color.Blue.copy(alpha = 0.2f+ audioLevel * 0.8f)
        val color2 = Color.Red.copy(alpha = 0.2f+ audioLevel * 0.8f)

        Surface(
            modifier = Modifier
                .background(Brush.linearGradient(listOf(color1, color2)))
                .fillMaxSize(),
            color = MaterialTheme.colorScheme.background
        ) {
            Column {
                Text("Room: ${title} - ${participants.size} - id ${call.id}")
                Text("${description}")
                DominantSpeaker(dominantSpeaker)
                LazyVerticalGrid(
                    columns = GridCells.Adaptive(minSize = 128.dp)
                ) {
                    items(otherParticipants.size) { index ->
                        val participant = otherParticipants[index]
                        ParticipantAvatar(participant)
                    }
                }
                Button(onClick = {
                    lifecycleScope.launch {
                        call.goLive()
                    }
                }) {
                    Text(text = "Go Live")
                }
            }
        }
    }
}
```


### Step 5 - Go live and join from the browser

Run the sample app now and you'll see 1 participant.
Click the go live button to allow participants to join.

To make this a little more interactive let's join the call from your browser.
Visit https://getstream.io/video/demos/?id=222&skip-intro=1 and join the call.
On your Android emulator you'll see the text update to 2 participants.

Note how the web interface won't allow you to share your audio/video.
The reason for this is that by default the audio_room call type only allows
moderators or admins to speak. Regular participants can request permission.
And if different defaults make sense for your app you can edit the call type in the dashboard or create your own.

### Step 6 - Requesting permission to speak

Requesting permission to speak is easy.

```kotlin
val response = call.requestPermissions("send-audio")
// and next the admin will call
val requests = call.state.permissionRequests.value
request.forEach {
    it.grant() // or it.reject()
}
```

### Others

* Query Calls (showing a list of upcoming calls)
* Reactions
* Recording
* Backstage
* Chat
* Moderation endpoints

### Conclusion

Building an audio room took about 10 minutes.

* Calls run on a global edge network for optimal latency
* There is no cap to how many listeners you can have in a room
* Audio quality is optimized using Opus RED & Opus DTX

If you want to add chat you should also review our Kotlin Chat Tutorial.


