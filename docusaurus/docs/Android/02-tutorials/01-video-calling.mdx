---
title: Video Call Tutorial
description: How to build a video call similar to Zoom or facebook messenger
---

## TODO:

- [ ] Generate user info and token for usage in this demo (currently hardcoded)

## Video Call Tutorial

This tutorial teaches you how to build your own Zoom/Whatsapp style video calling.

* Calls run on Stream's global edge network for optimal latency & reliability.
* Permissions give you fine grained control over who can do what.
* Video quality and codecs are automatically determined.

### Step 1 - Create a new project in android studio

Note that this tutorial was written using Android Studio Flamingo.
Setup steps can vary slightly across Android Studio versions so if you run into trouble be sure to use the latest version of Android Studio.

1. Create a new project
2. Select Phone & Template -> **empty activity**
3. Name your project **VideoCall**.

### Step 2 - Install the SDK & Setup the client

**Add the compose SDK** to your app's `build.gradle` file found in app/build.gradle
If you're new to android note that there are 2 build.gradle files, you want to open the one in the app folder.

```groovy
dependencies {
    implementation "io.getstream:stream-video-android-compose:$stream_version"
}
```

### Step 3 - Create & Join a call

Open up `MainActivity.kt` and replace it with:

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // create a user.
        val user = User(
            id = "tutorial@getstream.io", // any string
            name = "Tutorial" // name and image are used in the UI
        )

        // for a production app we recommend adding the client to your Application class or di module.
        val client = StreamVideoBuilder(
             context = applicationContext,
             apiKey = "hd8szvscpxvd", // demo API key
             geo = GEO.GlobalEdgeNetwork,
             user = user,
             token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoidHV0b3JpYWxAZ2V0c3RyZWFtLmlvIiwiaXNzIjoicHJvbnRvIiwic3ViIjoidXNlci90dXRvcmlhbEBnZXRzdHJlYW0uaW8iLCJpYXQiOjE2ODYwNTkzNDQsImV4cCI6MTY4NjA3MDE0OX0.F52ZJeDBLbvOE3DdAISOvwd-YVO3q3rg5bTgzNE_P9k",
        ).build()

        // join a call, which type is `default` and id is `123`.
        val call = client.call("default", "123")
        lifecycleScope.launch {
            call.join(create = true)
        }

        setContent {
            VideoTheme {
                val participants = call.state.participants.collectAsState()
                val connection = call.state.connection.collectAsState()
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = VideoTheme.colors.appBackground
                ) {
                    if (connection.value != RealtimeConnection.Connected) {
                        Text("loading...")
                    } else {
                        Text("Call ${call.id} has ${participants.value.size} participants", fontSize = 30.sp,  color = Color.Blue)
                    }
                }
            }
        }
    }
}
```

Run the sample app now and you'll see 1 participant.
To make this a little more interactive let's join the call from your browser.
Visit https://getstream.io/video/demos/?id=123&skip-intro=1 and join the call.
On your Android emulator you'll see the text update to 2 participants.
Let's keep the browser tab open as you go through the tutorial.

Awesome, time to actually render some video for these participants.

### Step 4 - Rendering Video

In this next step we're going to:

1. Render your local video.
2. Render the participant's video.

And replace the setContent code in MainActivity.kt

```kotlin
setContent {
    VideoTheme {
        val participants = call.state.remoteParticipants.collectAsState()
        val me = call.state.me.collectAsState()
        val connection = call.state.connection.collectAsState()
        var parentSize: IntSize by remember { mutableStateOf(IntSize(0, 0)) }


        Surface(
            modifier = Modifier.fillMaxSize().onSizeChanged { parentSize = it },
            color = VideoTheme.colors.appBackground
        ) {
            if (connection.value != RealtimeConnection.Connected) {
                Text("loading...")
            }
            // floating video UI for the local video participant
            me.value?.let {
                FloatingParticipantVideo(
                    call = call,
                    localParticipant = it,
                    parentBounds = parentSize
                )
            }

            // basic, video only rendering of the participant
            val remoteParticipant = participants.value.firstOrNull()
            val remoteVideo = remoteParticipant?.video?.collectAsState()
            if (remoteParticipant != null) {
                Column(modifier = Modifier.fillMaxSize()) {
                    VideoRenderer(
                        modifier = Modifier.weight(1f),
                        call = call,
                        video = remoteVideo?.value
                    )
                }
            }
        }
    }
}
```

You'll now see your local video in a floating video element and the video from your browser as well.

### Step 5 - A full UI

The above example showed how to use the call state object and compose to build a basic video UI.
For a production version of calling you'd want a few more UI elements:

* Indicators of when someone is speaking
* Quality of their network
* Layout support for >2 participants
* Labels for the participant names
* Call header and controls

Stream ships with some several Compose components to make this easy.
You can customize the components with theming, arguments and swapping parts of them.
This is convenient if you want to quickly build a production ready calling experience for you app.
(and if you need more flexibility, many customers use the above low level approach to build a UI from scratch)

Let's show how to use Stream's UI components to build a full call UI:

#### A. Extend the abstract call activity & use the call view model

```kotlin
// Extend the abstract call activity
class MainActivity : AbstractCallActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        ....
            call.join(create = true)
        }

        // create a view model just below call. join
        val factory = CallViewModelFactory(call = call)
        val vm by viewModels<CallViewModel> { factory }

        ....


        }
    }
}
```

Using the viewmodel and abstract call enables picture in picture and full screen support.
(It's quite easy to look at these classes and implement your own viewmodel or activity)

#### B. Render the UI with the call Container

Next up we want to render a call header, call controls and a more flexible grid layout for participants.

```kotlin
setContent {
    VideoTheme {
        CallContainer(
            modifier = Modifier.fillMaxSize(),
            callViewModel = vm,
            onBackPressed = { finish() },
        )
    }
}
```

The result will be:

![Compose CallContainer](../assets/compose_call_container.png)

When you now run your app you'll see a more polished video UI.
It supports reactions, screensharing, active speaker detection, network quality indicators etc.

### Step 6 - Customizing the UI

You can customize the UI by:

* Building your own UI components
* Mixing and matching with Stream's UI Components
* Theming

The example below shows how to swap out the call controls for your own controls:

```kotlin
VideoTheme {
    CallContainer(
        modifier = Modifier.fillMaxSize(),
        callViewModel = vm,
        onBackPressed = { finish() },
        callControlsContent = {
            ControlActions(
                callViewModel = vm,
                actions = listOf(
                    {
                        ToggleCameraAction(
                            modifier = Modifier.size(52.dp),
                            isCameraEnabled = isCameraEnabled, // or vm.callDeviceState.value.isCameraEnabled
                            onCallAction =  { .. } // or vm::onCallAction
                        )
                    },
                    {
                        ToggleMicrophoneAction(
                            modifier = Modifier.size(52.dp),
                            isMicrophoneEnabled = isMicrophoneEnabled,
                            onCallAction = { .. }
                        )
                    },
                    {
                        FlipCameraAction(
                            modifier = Modifier.size(52.dp),
                            onCallAction = { .. }
                        )
                    },
                ),
                onCallAction = vm::onCallAction
            )
        },
    )
}
```

Stream's Video SDK provides fully polished UI components, allowing you to build a video call quickly and customize them. As you've seen before, you can implement a full complete video call screen with `CallContainer` composable in Jetpack Compose. The `CallContainer` composable consists of three major parts below:

- **callAppBarContent**: Content is shown that calls information or additional actions.
- **callControlsContent**: Content is shown that allows users to trigger different actions to control a joined call.
- **callContent**: Content shown to be rendered when we're connected to a call successfully.


Theming gives you control over the colors and fonts.


```kotlin
VideoTheme(
    colors = StreamColors.defaultColors().copy(appBackground = Color.Black),
    dimens = StreamDimens.defaultDimens().copy(callAvatarSize = 72.dp),
    typography = StreamTypography.defaultTypography().copy(title1 = TextStyle()),
    shapes = StreamShapes.defaultShapes().copy(avatar = CircleShape)
) {
  ..
}
```

### Recap

Please do let us know if you ran into any issues.
Our team is also happy to review your UI designs and offer recommendations on how to achieve it with Stream.

To recap what we've learned:

* You setup a call: (val call = client.call("default", "123"))
* The call type ("default" in the above case) controls which features are enabled and how permissions are setup
* When you join a call, realtime communication is setup for audio & video calling: (call.join())
* Stateflow objects in call.state and call.state.participants make it easy to build your own UI
* VideoRenderer is the low level component that renders video

Calls run on Stream's global edge network of video servers.
By being closer to your users the latency and reliability of calls are better.
The SDKs enable you to build in-app video calling, audio rooms and livestreaming in days.

We hope you've enjoyed this tutorial and please do feel free to reach out if you have any suggestions or questions.
