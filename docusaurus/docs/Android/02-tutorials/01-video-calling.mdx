---
title: Video Call Tutorial
description: How to build a video call similar to Zoom or facebook messenger
---

## TODO:

- [ ] Generate user info and token for usage in this demo

## Video Call Tutorial

This tutorial teaches you how to build your own Zoom/Whatsapp style video calling.

* Calls run on Stream's global edge network for optimal latency & reliability.
* Permissions give you fine grained control over who can do what.
* Video quality and codecs are automatically determined.

### Step 1 - Create a new project in android studio

Note that this tutorial was written using Android Studio Flamingo.
Setup steps can vary slightly across Android Studio versions so if you run into trouble be sure to use the latest version of Android Studio.

1. Create a new project
2. Select Phone & Template -> **empty activity**
3. Name your project **VideoCall**.

### Step 2 - Install the SDK & Setup the client

**Add the compose SDK** to your app's `build.gradle` file found in app/build.gradle
If you're new to android note that there are 2 build.gradle files, you want to open the one in the app folder.

```groovy
dependencies {
    implementation "io.getstream:stream-video-android-compose:$stream_version"
}
```

### Step 3 - Create & Join a call

Open up `MainActivity.kt` and replace it with:

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // create a user.
        val user = User(
            id = "tutorial@getstream.io", // any string
            name = "Tutorial" // name and image are used in the UI
        )

        // for a production app we recommend adding the client to your Application class or di module.
        val client = StreamVideoBuilder(
             context = applicationContext,
             apiKey = "hd8szvscpxvd", // demo API key
             geo = GEO.GlobalEdgeNetwork,
             user = user,
             token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoidHV0b3JpYWxAZ2V0c3RyZWFtLmlvIiwiaXNzIjoicHJvbnRvIiwic3ViIjoidXNlci90dXRvcmlhbEBnZXRzdHJlYW0uaW8iLCJpYXQiOjE2ODYwNDAwOTUsImV4cCI6MTY4NjA1MDkwMH0.9m1wNAsn6UZHKu0i4_EWWw-sTBnbgDcV85Nmmbh7FNM",
        ).build()

        // join a call, which type is `default` and id is `123`.
        val call = client.call("default", "123")
        lifecycleScope.launch {
            call.join(create = true)
        }

        setContent {
            VideoTheme {
                val participants = call.state.participants.collectAsState()
                val connection = call.state.connection.collectAsState()
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = VideoTheme.colors.appBackground
                ) {
                    if (connection.value != RealtimeConnection.Connected) {
                        Text("loading...")
                    } else {
                        Text("Call ${call.id} has ${participants.value.size} participants", fontSize = 30.sp,  color = Color.Blue)
                    }
                }
            }
        }
    }
}
```

Run the sample app now and you'll see 1 participant.
To make this a little more interactive let's join the call from your browser.
Visit https://getstream.io/video/demos/?id=123&skip-intro=1 and join the call.
On your Android emulator you'll see the text update to 2 participants.
Let's keep the browser tab open as you go through the tutorial.

Awesome, time to actually render some video for these participants.

### Step 4 - Rendering Video

In this next step we're going to:

1. Render your local video.
2. Render the participant's video.

And replace the set content

```kotlin
setContent {
    VideoTheme {
        val participants by call.state.remoteParticipants.collectAsState()
        val me by call.state.me.collectAsState()
        val connection = call.state.connection.collectAsState()

        Surface(
            modifier = Modifier.fillMaxSize(),
            color = VideoTheme.colors.appBackground
        ) {
            if (connection.value != RealtimeConnection.Connected) {
                Text("loading...")
            }
            // floating video UI for the local video participant
            FloatingParticipantVideo(call = call, participant = me)

            // basic, video only rendering of the participant
            val remoteParticipant = participants.firstOrNull()
                if (remoteParticipant != null) {
                Column(modifier = Modifier.fillMaxSize()) {
                    VideoRenderer(
                        modifier = Modifier.weight(1f),
                        call = call,
                        video = participant.video,
                    )
                 }
            }
        }
    }
```

### Step 5 - A full UI

The above example showed how to use the call state object and compose to build a basic video UI.
For a production version of calling you'd want a few more UI elements:

* Indicators of when someone is speaking
* Quality of their network
* Layout support for >2 participants
* Labels for the participant names

Stream ships with some more complete Compose components for this purpose.
You can customize them with theming, arguments and swapping them with your own components.
This is convenient if you want to quickly build a production ready calling experience for you app.
(and if you need more flexibility, many customers use the above low level approach to build a UI from scratch)

We're making 3 changes:

A. Extend the abstract call activity & use the call view model

```kotlin
// Extend the abstract call activity
class MainActivity : AbstractCallActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        ....
            call.join(create = true)
        }

        // create a view model just below call. join
        val factory = CallViewModelFactory(call = call)
        val vm by viewModels<CallViewModel> { factory }

        ....


        }
    }
}
```

B. Render the UI with the call Container






Stream's video SDK includes UI components that make it simple to launch a video calling experience in hours.
Now that we've seen how to use the lower level APIs, lets build a fully polished calling experience with the example below:

```kotlin
setContent {
    VideoTheme {
        CallContainer(
            modifier = Modifier.fillMaxSize(),
            callViewModel = vm,
            onBackPressed = { finish() },
        )
    }
}
```

The result will be:

![Compose CallContainer](../assets/compose_call_container.png)

When you now run your app you'll see a more polished video UI.
It supports reactions, screensharing, active speaker detection, network quality indicators etc.

### Step 6 - Customizing the UI

All UI components in the SDK use our pre-defined themes and you can easily customize them in Jetpack Compose. You can customize the theme with the 4 components below:

- **StreamColor**: This is used to decided colors of UI components.
- **StreamDimens**: This is used to decide the size of UI components.
- **StreamTypography**: This is used to decide the text styles of UI components.
- **StreamShapes**: This is used to decide the shapes of UI components.

In Jetpack Compose, you can simply customize those styles by passing the value into the `VideoTheme` like the example below:

```kotlin
VideoTheme(
    colors = if (isSystemInDarkTheme()) {
        StreamColors.defaultDarkColors().copy(appBackground = Color.Black)
    } else {
        StreamColors.defaultColors().copy(appBackground = Color.White)
    }
) {
    CallContainer(
        modifier = Modifier.fillMaxSize(),
        callViewModel = vm,
        onBackPressed = { finish() },
    )
}
```

With the same approaches, you can customize the rest of other styles:

```kotlin
VideoTheme(
    colors = StreamColors.defaultColors().copy(appBackground = Color.Black),
    dimens = StreamDimens.defaultDimens().copy(callAvatarSize = 72.dp),
    typography = StreamTypography.defaultTypography().copy(title1 = TextStyle()),
    shapes = StreamShapes.defaultShapes().copy(avatar = CircleShape)
) {
  ..
}
```

Stream's Video SDK provides fully polished UI components, allowing you to build a video call quickly and customize them. As you've seen before, you can implement a full complete video call screen with `CallContainer` composable in Jetpack Compose. The `CallContainer` composable consists of three major parts below:

- **callAppBarContent**: Content is shown that calls information or additional actions.
- **callControlsContent**: Content is shown that allows users to trigger different actions to control a joined call.
- **callContent**: Content shown to be rendered when we're connected to a call successfully.

In the example below, you'll see how to customize each parts of the `CallContainer` composable:

```kotlin
VideoTheme {
    CallContainer(
        modifier = Modifier.fillMaxSize(),
        callViewModel = vm,
        callType = CallType.VIDEO,
        onBackPressed = { finish() },
        callAppBarContent = { /** custom call app bar */ },
        callControlsContent = {
            ControlActions(
                callViewModel = vm,
                actions = listOf(
                    {
                        ToggleCameraAction(
                            modifier = Modifier.size(52.dp),
                            isCameraEnabled = isCameraEnabled, // or vm.callDeviceState.value.isCameraEnabled
                            onCallAction =  { .. } // or vm::onCallAction
                        )
                    },
                    {
                        ToggleMicrophoneAction(
                            modifier = Modifier.size(52.dp),
                            isMicrophoneEnabled = isMicrophoneEnabled,
                            onCallAction = { .. }
                        )
                    },
                    {
                        FlipCameraAction(
                            modifier = Modifier.size(52.dp),
                            onCallAction = { .. }
                        )
                    },
                ),
                onCallAction = vm::onCallAction
            )
        },
        callContent = { /** custom call content */ },
    )
}
```

### Step 7 - PIP

To truly make the experience solid the call should continue running in the background using PIP.
We'll implement this by subclassing the **AbstractCallActivity** class and leveraging the **CallViewModel**.


### Other Possibilities

* **Ringing**: If you want to ring the other participants before the docs explain how to do this here:
* **Push Notifications**:
* **Reactions**:
* **Chat Integration**:


### Conclusion

And that's all it takes to build a full calling experience with Stream.

Mention that we also have quickstarts for livestream and audio rooms
Repeat why you should use Stream
Repeat why this SDK is awesome

