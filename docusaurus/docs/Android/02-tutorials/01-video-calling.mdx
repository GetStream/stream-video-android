---
title: Video Call Tutorial
description: How to build a video call similar to Zoom or facebook messenger
---

## Video Call Tutorial

This tutorial teaches you how to build your own Zoom/Whatsapp style video calling.

* Calls run on Stream's global edge network for optimal latency & reliability.
* Permissions give you fine grained control over who can do what.
* Video quality and codecs are automatically determined.

### Step 1 - Create a new project in android studio

This tutorial was written using Android Studio Flamingo.
Setup steps can vary slightly across Android Studio versions so if you run into trouble be sure to use the latest version of Android Studio.

1. Create a new project
2. Select Phone & Template -> **empty activity**
3. Name your project **VideoCall**.

### Step 2 - Install the SDK & Setup the client

**Add the video compose SDK** to your app's `build.gradle` file found in app/build.gradle
If you're new to android note that there are 2 build.gradle files, you want to open the one in the app folder.

```groovy
dependencies {
    implementation "io.getstream:stream-video-android-compose:0.0.14-SNAPSHOT"
}
```

(We also have a core SDK for video that excludes compose if you prefer XML layouts)

### Step 3 - Create & Join a call

Open up `MainActivity.kt` and replace it with:

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // step1 - create a user.
        val user = User(
            id = "tutorial@getstream.io", // any string
            name = "Tutorial", // name and image are used in the UI
            role = "admin"
        )

        // step2 - initialize StreamVideo. For a production app we recommend adding the client to your Application class or di module.
        val client = StreamVideoBuilder(
             context = applicationContext,
             apiKey = "hd8szvscpxvd", // demo API key
             geo = GEO.GlobalEdgeNetwork,
             user = user,
             token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoidHV0b3JpYWxAZ2V0c3RyZWFtLmlvIiwiaXNzIjoicHJvbnRvIiwic3ViIjoidXNlci90dXRvcmlhbEBnZXRzdHJlYW0uaW8iLCJpYXQiOjE2ODYxMjM5NzUsImV4cCI6MTY4NjEzNDc4MH0.HzfOiuj64waDs4naN6SsNZpusb8N6R7drMfx7bsxpok",
        ).build()

        // step3 - join a call, which type is `default` and id is `123`.
        val call = client.call("default", "123")
        lifecycleScope.launch {
            call.join(create = true)
        }

        setContent {
            // step4 - observe call participants inside VideoTheme
            VideoTheme {
                val participants by call.state.participants.collectAsState()
                val connection by call.state.connection.collectAsState()

                Box(
                    contentAlignment = Alignment.Center,
                    modifier = Modifier.fillMaxSize()
                ) {
                    if (connection != RealtimeConnection.Connected) {
                        Text("loading...", fontSize = 30.sp)
                    } else {
                        Text("Call ${call.id} has ${participants.size} participants", fontSize = 30.sp)
                    }
                }
            }
        }
    }
}
```

Run the sample app now and you'll see 1 participant (yourself).
Let's review what we did in the above code.

**User** setup. First we create a user object.
You typically sync these users via a server side integration from your own backend.
Alternatively you can also use guest or anonymous users.
The user's role allows you to configure permissions in the video call.

```kotlin
val user = User(
    id = "tutorial@getstream.io", // any string
    name = "Tutorial", // name and image are used in the UI
    role = "admin"
)
```

Next we setup the video SDK and join the call.

```kotlin
val call = client.call("default", "123")
lifecycleScope.launch {
    call.join(create = true)
}
```

As soon as you use `call.join` the connection for video & audio is setup.

Last the UI looks up the stateflow objects in `call.state`.
You'll find all relevant state for the call in `call.state` and `call.state.participants`.
The docs on [Call state and Participant state](../03-guides/03-call-and-participant-state.mdx) explains this in further detail.

```kotlin
val participants by call.state.participants.collectAsState()
val connection by call.state.connection.collectAsState()
```

### Step 4 - Joining from the web

To make this a little more interactive let's join the call from your browser.
Visit [Stream Video Demo](https://getstream.io/video/demos/?id=123&skip-intro=1) and join the call.
On your Android emulator you'll see the text update to 2 participants.
Let's keep the browser tab open as you go through the tutorial.

Awesome, time to actually render some video for these participants.

### Step 5 - Rendering Video

In this next step we're going to:

1. Render your local video.
2. Render the participant's video.

And replace the `setContent` code with the example below in the `MainActivity.kt` file:

```kotlin
setContent {
    VideoTheme {
        val remoteParticipants by call.state.remoteParticipants.collectAsState()
        val remoteParticipant = remoteParticipants.firstOrNull()
        val me by call.state.me.collectAsState()
        val connection by call.state.connection.collectAsState()
        var parentSize: IntSize by remember { mutableStateOf(IntSize(0, 0)) }

        Box(
            contentAlignment = Alignment.Center,
            modifier = Modifier
                .fillMaxSize()
                .background(VideoTheme.colors.appBackground)
                .onSizeChanged { parentSize = it }
        ) {
            if (remoteParticipant != null) {
                Column(modifier = Modifier.fillMaxSize()) {
                    ParticipantVideo(
                        modifier = Modifier.weight(1f),
                        call = call,
                        participant = remoteParticipant,
                    )
                }
            } else {
                if (connection != RealtimeConnection.Connected) {
                    Text(
                        text = "loading...",
                        fontSize = 30.sp,
                        color = VideoTheme.colors.textHighEmphasis
                    )
                } else {
                    Text(
                        modifier = Modifier.padding(30.dp),
                        text = "Join call ${call.id} in your browser",
                        fontSize = 30.sp,
                        color = VideoTheme.colors.textHighEmphasis,
                        textAlign = TextAlign.Center
                    )
                }
            }

            // floating video UI for the local video participant
            if (me != null) {
                FloatingParticipantVideo(
                    modifier = Modifier.align(Alignment.TopEnd),
                    call = call,
                    participant = me!!,
                    parentBounds = parentSize
                )
            }
        }
    }
}
```

You'll now see your local video in a floating video element and the video from your browser as well.
The end result should look like this:

![Video Tutorial](../assets/portrait-video-two.png)

### Step 6 - A full UI

The above example showed how to use the call state object and compose to build a basic video UI.
For a production version of calling you'd want a few more UI elements:

* Indicators of when someone is speaking
* Quality of their network
* Layout support for >2 participants
* Labels for the participant names
* Call header and controls

Stream ships with some several Compose components to make this easy.
You can customize the components with theming, arguments and swapping parts of them.
This is convenient if you want to quickly build a production ready calling experience for you app.
(and if you need more flexibility, many customers use the above low level approach to build a UI from scratch)

Let's show how to use Stream's UI components to build a full call UI:

#### A. Extend the abstract call activity & use the call view model

```kotlin
// Extend the abstract call activity
class MainActivity : AbstractCallActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        ...

        }
    }
}
```

Using the viewmodel and abstract call enables picture in picture and full screen support.
(It's quite easy to look at these classes and implement your own viewmodel or activity)

#### B. Render the UI with the call Container

Next up we want to render a call header, call controls and a more flexible grid layout for participants.

```kotlin
setContent {
    VideoTheme {
        CallContainer(
            modifier = Modifier.fillMaxSize(),
            callViewModel = vm,
            onBackPressed = { finish() },
        )
    }
}
```

The result will be:

![Compose CallContainer](../assets/compose_call_container.png)

When you now run your app you'll see a more polished video UI.
It supports reactions, screensharing, active speaker detection, network quality indicators etc.

### Step 7 - Customizing the UI

You can customize the UI by:

* Building your own UI components
* Mixing and matching with Stream's UI Components
* Theming

The example below shows how to swap out the call controls for your own controls:

```kotlin
VideoTheme {
    val isCameraEnabled by call.camera.isEnabled.collectAsState()
    val isMicrophoneEnabled by call.microphone.isEnabled.collectAsState()

    CallContainer(
        modifier = Modifier.fillMaxSize(),
        call = call,
        callViewModel = vm,
        onBackPressed = { finish() },
        controlsContent = {
            ControlActions(
                call = call,
                actions = listOf(
                    {
                        ToggleCameraAction(
                            modifier = Modifier.size(52.dp),
                            isCameraEnabled = isCameraEnabled,
                            onCallAction = { call.camera.setEnabled(!it.isEnabled) }
                        )
                    },
                    {
                        ToggleMicrophoneAction(
                            modifier = Modifier.size(52.dp),
                            isMicrophoneEnabled = isMicrophoneEnabled,
                            onCallAction = { call.microphone.setEnabled(!it.isEnabled) }
                        )
                    },
                    {
                        FlipCameraAction(
                            modifier = Modifier.size(52.dp),
                            onCallAction = { }
                        )
                    },
                ),
            )
        }
    )
}
```

Stream's Video SDK provides fully polished UI components, allowing you to build a video call quickly and customize them. As you've seen before, you can implement a full complete video call screen with `CallContainer` composable in Jetpack Compose. The `CallContainer` composable consists of three major parts below:

- **callAppBarContent**: Content is shown that calls information or additional actions.
- **callControlsContent**: Content is shown that allows users to trigger different actions to control a joined call.
- **callContent**: Content shown to be rendered when we're connected to a call successfully.

Theming gives you control over the colors and fonts.

```kotlin
VideoTheme(
    colors = StreamColors.defaultColors().copy(appBackground = Color.Black),
    dimens = StreamDimens.defaultDimens().copy(callAvatarSize = 72.dp),
    typography = StreamTypography.defaultTypography().copy(title1 = TextStyle()),
    shapes = StreamShapes.defaultShapes().copy(avatar = CircleShape)
) {
  ..
}
```

### Recap

Please do let us know if you ran into any issues.
Our team is also happy to review your UI designs and offer recommendations on how to achieve it with Stream.

To recap what we've learned:

* You setup a call: (val call = client.call("default", "123"))
* The call type ("default" in the above case) controls which features are enabled and how permissions are setup
* When you join a call, realtime communication is setup for audio & video calling: (call.join())
* Stateflow objects in call.state and call.state.participants make it easy to build your own UI
* VideoRenderer is the low level component that renders video

Calls run on Stream's global edge network of video servers.
By being closer to your users the latency and reliability of calls are better.
The SDKs enable you to build in-app video calling, audio rooms and livestreaming in days.

We hope you've enjoyed this tutorial and please do feel free to reach out if you have any suggestions or questions.
