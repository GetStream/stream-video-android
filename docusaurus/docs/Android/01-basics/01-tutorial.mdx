## Introduction

Hello there and welcome to our Stream Video Android tutorial.

`StreamVideo` is an SDK that facilitates adding calling (audio and video) support to your apps. It's performant and highly customizable, allowing you to build various types of calling applications and streaming use cases, such as:

* **Messenger-style applications**: These applications implement Chat as a primary source of communication, with Video secondary.
* **Zoom-style applications**: Such apps focus primarily on Video, with Chat as a way to communicate while in a call.
* **Audio Rooms**: Our SDK allows you to build audio-only rooms that allow live communication, such as Twitter Spaces.
* **Livestreaming**: We support one of the most popular modern use cases - streaming audio and video to audiences. You can replicate apps like Twitch or YouTube Live.

This makes the Stream Video SDK the best-in-class choice when integrating Audio and Video communication in your apps. With all that in mind, let's dive into the tutorial.

## Tutorial Content

In this tutorial we'll cover the main steps required to produce a fully capable video chat app, using **Stream Video**. The application you're building is called `VideoTutorial` (fitting, I know), and its features will be the following:

- Creating a project & setting up Stream dependencies
- Authenticating the user
- Handling Stream Video lifecycle
- Creating & joining a Call
- Rendering Call UI and controls

By the end of the tutorial, you'll be more than capable of building an app that powers video calls, with deep knowledge of how our internal state management works. The app has only a few screens:

* **Login screen**: Used to select a user for the Calls. 
* **Home screen**: Used to choose a Call ID, its participate and if you want to start a ringing or meeting call.
* **Call screen**: Central place for all the communication after joining a call.

| LoginActivity                                    | HomeActivity      | CallActivity |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![Screenshot_1675241285](https://user-images.githubusercontent.com/17215808/215994873-6ab8dd74-c40d-4b74-81f8-9fc2b88a709e.png) | ![Screenshot_1675241145](https://user-images.githubusercontent.com/17215808/215994945-9fd378de-12ef-42a7-b8d0-b831a50fa2f2.png) | ![Screenshot_1675242357](https://user-images.githubusercontent.com/17215808/216000813-86ebd384-f5d1-4e53-9b23-ce1f14b6de4e.png) |

If you're interested in what the application looks like and a small demo of how it works, make sure to check out the full [sample app](https://github.com/GetStream/stream-video-android/tree/main/app) in our repository.

Once you're ready, we can start with the project.

## Starting the Project

> **Note**: In this tutorial, we'll be using Compose for the UI, but you can very much build this in XML too. Our state is pragmatic and can be integrated with the UI toolkit you prefer.

To get started with [Stream Video](https://github.com/GetStream/stream-video-android), we have a great [starter project](https://github.com/GetStream/stream-video-android/tree/main/examples/tutorial/tutorial-starter) that pre-bakes all the boilerplate UI and dependency code for you. The best way to work through the tutorial is using this project. To use the project, do the following:

1. Clone our [Stream Video](https://github.com/GetStream/stream-video-android) repository to your local machine. If you're not sure how to clone the project, follow [GitHub's guide](https://docs.github.com/en/desktop/contributing-and-collaborating-using-github-desktop/adding-and-cloning-repositories/cloning-and-forking-repositories-from-github-desktop#cloning-a-repository).
2. Once you've downloaded the project install [Android Studio](https://developer.android.com/studio) if you haven't already. Follow the setup instruction to complete the process.
3. With Android Studio installed, open the starter project by using the **Open** button and navigating to the cloned repository. Find and open `examples/tutorial/tutorial-starter` folder.
4. You should be good to go!

> **Note**: Alternatively, if you install Android Studio first, you can use its **Get From VCS** button.
>
> ![Android Studio Menu](https://user-images.githubusercontent.com/17215808/216018367-ae7210e3-54ae-418d-a7e9-0f39f5f8ace5.png)

Once you clone and load the project, let it sync and download all the dependencies. Our SDKs are available from MavenCentral, and everything you need to align with our SDK in terms of the Kotlin and Compose versions is already prepared in the starter project.

Now that you have the project ready, check out the Stream dependencies. Open your `tutorial-stater` module's `build.gradle` file and look for the following:

```groovy
dependencies {
    implementation "io.getstream:stream-video-android-compose:1.0.0"
}
```

This dependency holds all the necessary code to authenticate a user, start a Stream Video client, create or join a call and connect to the call to start receiving audio and video tracks. At the same time, it provides the Jetpack Compose components that do all the heavy lifting of building UI for you, which you can customize in different ways.

Now that you've verified the project and loaded the Stream dependency, you can start with **user authentication**.

## Initializing the StreamVideo Client

To fully connect to the Stream Video API, you need to authenticate a user. Using our [documentation](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/02-guides/01-authentication.mdx) for reference you should be able to obtain a user token that contains all the information about a given user in your app. However, in this example, we have predefined users to make the process easier, and you won't have to perform the authentication.

> **Note**: Stream provides a [low-level client](.../04-client/01-overview.mdx) and both [XML](03-ui/04-xml/01-overview.mdx) and [Compose](03-ui/03-compose/01-overview.mdx) UI components to help you integrate video calling features. These artifacts help you integrate complex and performant features, with the least amount of code possible, while still opening the door for deep customization.
>
> We'll touch upon UI later in the tutorial - for now, let's first create our Client.

Open the file called `VideoApp.kt` and you'll find two TODO items:

```kotlin
fun initializeStreamVideo(
    credentialsProvider: CredentialsProvider,
    loggingLevel: LoggingLevel
): StreamVideo {
    TODO("Implement Stream Video")
}
```

The first item is for initializing the `StreamVideo` client. It serves as the main entry point to all the API calls and state exposed by our SDK. You can use it to create new calls, join existing, call other participants and observe the call state.

The second item is for logging the user out:

```kotlin
fun logOut() {
    // TODO - log the user out
}
```

Because our `StreamVideo` client lives as long as there's an active user, if you log out you should clean up state.

To implement this behavior, replace the TODO items with the following two pieces of code:

```kotlin
class VideoApp : Application() {

    fun initializeStreamVideo(
        credentialsProvider: CredentialsProvider,
        loggingLevel: LoggingLevel
    ): StreamVideo { 
        if (this::credentialsProvider.isInitialized) { // 1
            this.credentialsProvider.updateUser(
                credentialsProvider.getUserCredentials()
            )
        } else {
            this.credentialsProvider = credentialsProvider
        }

        return StreamVideoBuilder( // 2
            context = this,
            credentialsProvider = this.credentialsProvider, // 3
            androidInputs = emptySet(), // 4
            loggingLevel = loggingLevel
        ).build().also {
            streamVideo = it // 5
        }
    }

    fun logOut() {
        // 6
        streamVideo.clearCallState()
        streamVideo.removeDevices(userPreferences.getDevices())
        userPreferences.clear() // 7
    }
}
```

There are a few steps and important parts of this setup. If you look at the rest of the file, there are some properties already prepared, like `streamVideo`, `credentialsProvider`, `userPreferences` and so on. These are used to persist the user within the app, while they're logged in. You'll utilize them throughout the app.

In the snippets themselves, you're doing the following:

1. You check if the `credentialsProvider` is already initialized or not. If it is, you update the user data, otherwise you initialize the provider. This is helpful when logging a user in or out, as you're able to persist the data accordingly.

2. Using `StreamVideoBuilder`,  you gain access to our client. You pass in the `context` used for internal preferences setup, the `credentialsProvider` for the user and API key data, `androidInputs` and the `loggingLevel` used to log information to Logcat.

3. It's important to pass in the persisted `credentialsProvider` instance in case you log in/out, to update the internal SDK.

4. We'll touch upon `androidInputs` later, but they're used to automate the navigation to Calls when you receive or start a Call.

5. After building the client using `StreamVideoBuilder.build()`, you set the local instance so you can reuse it.

   > **Note**: For the sake of simplicity, we're not using nullable properties for the client here, but rather `lateinit var`. We recommend releasing the instance of the `StreamVideo` client as soon as your user logs out.

6. Finally, when the user logs out, you have to clear up the state. Read more about our [SDK lifecycle](../02-guides/02-call-lifecycle.mdx) to learn how to best handle this scenario.

7. After clearing the client and the Call state, you can also clear the `userPreferences`, to remove the stored credentials and the API key.

With this in place, you've built all the code required to initialize the client and you can move on to logging in the user.

## Authenticating the User

Now that you have the `StreamVideo` client ready, let's log in the user. Open `LoginActivity` and look for TODO item there.

```kotlin
private fun logIn(selectedUser: User) {
    // TODO - log in the user
    startActivity(HomeActivity.getIntent(this))
    finish()
}
```

All of the `LoginActivity` UI is already implemented for you. It shows a list of user items that you can select, as well as a **Login** button to enter the main part of the application. Because this code isn't directly related to Stream or our SDK, feel free to browse it to learn more, but it's not required.

To fully initialize the client, you need to use the provided `selectedUser` and an API key to kick things off. Do so the following way:

```kotlin
private fun logIn(selectedUser: User) {
    videoApp.initializeStreamVideo(
        credentialsProvider = AuthCredentialsProvider( // 1
            user = selectedUser,
            apiKey = VideoApp.API_KEY, // 2
        ),
        loggingLevel = LoggingLevel.BODY // 3
    )
    startActivity(HomeActivity.getIntent(this)) // 4
    finish()
}
```

Since the UI is already there, you only need to do the following:

1. You wrap the `selectedUser` and the `apiKey` into a `CredentialsProvider` that'll be used under the hood for all API calls.
2. Notice the `VideoApp.API_KEY`. Right now this is a hardcoded value to our tutorial environment, but in real-world, you'll need to pass in **your environment API key**.
3. To have a good overview of details from the SDK, we pass in `LoggingLevel.BODY`. This will log all the information we have for our API calls.
4. As soon as the client is initialized, you can start the `HomeActivity` and finish with login.

Now build and run the project and you should be able to log in with a user.

| LoginActivity                                                | HomeActivity                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![Screenshot_1675241285](https://user-images.githubusercontent.com/17215808/215994873-6ab8dd74-c40d-4b74-81f8-9fc2b88a709e.png) | ![Screenshot_1675241145](https://user-images.githubusercontent.com/17215808/215994945-9fd378de-12ef-42a7-b8d0-b831a50fa2f2.png) |

To round up the authentication experience, you need to finish the logging out part of `HomeActivity`. Open `HomeActivity.kt` and look for the `logOut` function:

```kotlin
private fun logOut() {
    // TODO - log out
    startActivity(Intent(this, LoginActivity::class.java))
    finish()
}
```

It'll finish the `HomeActivity` and start `LoginActivity` again when you tap the **Log Out** button. Replace the TODO item with the following:

```kotlin
private fun logOut() {
    videoApp.logOut() // here
    startActivity(Intent(this, LoginActivity::class.java))
    finish()
}
```

Since you've implemented `VideoApp.logOut()`, it's only right to call it here. Build and run the app again. You should be able to log out now and any state present in the `StreamVideo` client or the `UserPreferences` should be cleared up.

User authentication and SDK initialization is only one part of the story. What remains is to let the user create meeting calls as well as ring people from the app. Let's do that next.

## Creating Meetings

Stream supports several different [call types](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/02-guides/10-configuring-call-types.mdx). Based on the type of your Call, you might want it to act like a meeting room, audio room, livestream channel or just a plain ringing call. This comes in hand with different capabilities that are present in such calls, but more on that later.

For now, let's see how to create a meeting call first. Open `HomeActivity` and head over to `createMeeting()`. It's currently empty, so add the following code to implement meeting behavior:

```kotlin
private fun createMeeting(callId: String, participants: List<String>) {
    lifecycleScope.launch {
        loadingState.value = true // 1

        val result = streamVideo.joinCall( // 2
            type = "default",
            id = callId,
            participantIds = participants,
            ringing = false
        )

        loadingState.value = false

        result.onError { // 3
            Toast.makeText(this@HomeActivity, it.message, Toast.LENGTH_SHORT).show()
        }
    }
}
```

This piece of code is quite straightforward in what it does:

1. You first set the `loadingState` flag to `true`. This will show a UI spinner to the user, until the API call is done, when it's set back to `false`.
2. Using `joinCall` you can connect to a Call using a type and an ID, with some optional parameters.
   * The `type` is used to define what kind of capabilities the call has, for now it's `default`.
   * The `callId` will be whatever the user writes within the input field.
   * `participantIds` allow you to add other people to the call as members.
   * And finally, `ringing` is used to trigger an **incoming call** prompt to any members of the call. Because you're creating a meeting, you won't be ringing other participants. They'll have to join the call manually or using a deep link.
3. In case the API call fails, you show an error message to the user for more information.

That's all you need to do to create a meeting. Simply pass in the ID and type of the Call, as well as which people you want to add. Internally, the `StreamVideo` client will create the corresponding `CallClient`, which handles all the WebRTC logic around publishing and subscribing to tracks and different events. You can learn more about the `CallClient` it its [respective documentation](../04-client/03-call-client.mdx).

Notice how you handled `onError` but didn't cover the `onSuccess` clause. You might be thinking, how will you start the UI for the call after joining. We have a great quality-of-life feature that lets you automate which `Activity` is opened when the Call state changes to Incoming, Outgoing or Joined, called `CallAndroidInput`s.

### Adding CallAndroidInputs

Calls have quite a complex lifecycle. If you're being called (ringed) by someone, or you're ringing someone else, you need to show the appropriate UI to users for both cases. Moreover, as the state changes, you need to reflect it in the UI, to let the user know what's going on.

The situation gets ever trickier when dealing with background Calls. Users expect that a Call works even if they leave the main screen to open their email, go through some notes and similar.

We cover all of these scenarios in an abstract way and let you further customize the experience to cater to your app's and users' needs.

If you're looking for an easy `Activity` that handles the state and UI rendering out of the box, while at the same time requests appropriate permissions from the user, we provide `AbstractComposeCallActivity` and `AbstractXMLCallActivity`, for Jetpack Compose and XML users, respectively. You simply have to inherit from these constructs and you're good to go.

And to support Calls in the background, we provide `AbstractStreamCallService` that lets you show UI information to the user that a Call is running, which lets you keep your app alive even if the user leaves the main screen.

If you search for `CallActivity` and `CallService` in the project, you'll find the following:

```kotlin
class CallActivity : AbstractComposeCallActivity() {

    override fun getStreamVideo(context: Context): StreamVideo = context.videoApp.streamVideo // 1

    override fun getCallViewModelFactory(): CallViewModelFactory { // 2
        return CallViewModelFactory(
            streamVideo = getStreamVideo(this),
            permissionManager = getPermissionManager(),
            usersProvider = if (BuildConfig.DEBUG) FakeUsersProvider() else EmptyUsersProvider // 3
        )
    }
}

class CallService : AbstractStreamCallService() {

    override fun getStreamVideo(context: Context): StreamVideo = videoApp.streamVideo // 4
}
```

These two constructs are already implemented for you, you just need to plug them into the app. The important parts are the following:

1. The only function required to inherit from `AbstractComposeCallActivity` is `getStreamVideo()`. We cannot define the instance for you, since it's not a singleton, so you have to provide your static instance to the class.
2. Similarly, you can choose to provide `getCallViewModelFactory()`. It's optional, but it lets you override the `permissionManager` and `usersProvider` properties that let you customize the `ViewModel` behavior.
3. In this case, you opted in to provide a `FakeUsersProvider` in debug builds, which will let you invite fake people to calls to test that feature.
4. Similar to `CallActivity`, your `CallService` also requires a `StreamVideo` instance to enable the call to be in the background.

Now that you've learned what these two classes do, it's time to integrate them into your app.

Open `AndroidManifest.xml` and declare these components like so:

```xml
<application ...>
        <activity
            android:name=".ui.call.CallActivity"
            android:configChanges="screenSize|smallestScreenSize|screenLayout|orientation"
            android:supportsPictureInPicture="true" />

        <service
            android:name=".ui.call.CallService"
            android:enabled="true"
            android:exported="false" />
</application>
```

This should be easy to understand, but there are a few more propeties you added while declaring the `CallActivity`:

* `configChanges`: You declare that your app is responsible for screen size, layour or orientation configuration changes. This is used for Picture-In-Picture (PiP) mode.
* `supportsPictureInPicture`: Necessary to enable PiP for a given `Activity`.

You'll learn more about our PiP support later in the tutorial. Now that you've declared these components in the manifest, it's time to pass them in as `CallAndroidInput`s to `StreamVideo`.

Open `VideoApp.kt` and change the following piece of code in `initializeStreamVideo()`:
```kotlin
fun initializeStreamVideo(
    credentialsProvider: CredentialsProvider,
    loggingLevel: LoggingLevel
): StreamVideo {
    if (this::credentialsProvider.isInitialized) {
        this.credentialsProvider.updateUser(
            credentialsProvider.getUserCredentials()
        )
    } else {
        this.credentialsProvider = credentialsProvider
    }

    return StreamVideoBuilder(
        context = this,
        credentialsProvider = this.credentialsProvider,
        androidInputs = setOf( // here
            CallServiceInput.from(CallService::class),
            CallActivityInput.from(CallActivity::class),
        ), 
        loggingLevel = loggingLevel
    ).build().also {
        streamVideo = it
    }
}
```

By passing in two inputs for `androidInputs`, you tell the SDK to start both the `CallActivity` and the `CallService`, whenever the internal Call state changes to **Incoming**, **Outgoing** or **Joined**.

Now build and run the app and you should be able to create a meeting with a meeting ID. If you do so, your app will automatically navigate to the `CallActivity`. Write down any Call ID into the input field on the Home screen, make sure that **ringing** is disabled and tap on **Create Meeting**.

| HomeActivity                                                 | CallActivity                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![home screen](https://user-images.githubusercontent.com/17215808/216074980-ba1274d2-8145-4833-b293-7427936a2e63.png) | ![Meeting](https://user-images.githubusercontent.com/17215808/216075073-d882b756-e242-4ca2-9e41-ff05569ad400.png) |

Great job. Notice how the `CallActivity` is automatically started and updated based on the state. Also notice the small phone icon in the status bar. This indicates the call is running and can persist in the background.

If you press the back or home buttons and go to the background, you should see the following UI that represents the PiP mode.

![Picture-in-Picture mode](https://user-images.githubusercontent.com/17215808/216076317-0c25f9f1-f350-47c5-aa81-3844e16235be.png)

Clicking on the PiP container gives you the option to close the Call or go back to it. You can move the container around and browse other apps while the call is running. Read through our documentation if you're interested in how our [Picture-In-Picture support](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/05-advanced/04-enable-picture-in-picture.mdx) works.

Now that you have a meeting Call created, anyone with the Call ID can join it. Alternatively, you can read up on our [Deep linking guide](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/05-advanced/01-deeplinking.mdx) to see how to implement deep links and share call invites using them. **Run the app on another emulator or device** and attempt to join the Call with the same ID but a different user to test this.

The next step is to explore ringing Calls and how they reflect the two UI cases - when you're calling other people and when other people are calling you.

## Ringing People

The logic to implement ringing is quite similar to meeting Calls. However, these are the main differences:

* Ringing **requires other participants** as you have to ring someone.
* In ringing scenarios, you don't join the Call by default, instead you **wait for callees to respond**.
* Callees can either **accept the Call** and fully initiate it for everyone who's been invited, or **reject the Call** and potentially cancel it if everyone rejected.
* Unlike meetings which are created and exist as open rooms to join, ringing Calls have a **customizable timeout**, after which the Call is canceled if not a single callee accepted to initiate the Call.

These difference represent the user experience of a ringing Call. But when integrating the difference is minimal. Open the `HomeActivity.kt` and look for `dialUsers()` which is currently empty. Replace that function with the following code:

```kotlin
private fun dialUsers(callId: String, participants: List<String>) { // 1
    lifecycleScope.launch {
        loadingState.value = true
      
        streamVideo.getOrCreateCall( // 2
            type = "default",
            id = callId,
            participantIds = participants,
            ringing = true
        ).onError {
            Toast.makeText(this@HomeActivity, it.message, Toast.LENGTH_SHORT).show() // 3
        }
        loadingState.value = false // 4
    }
}
```

This implementation is _very_ similar to creating a meeting. But, as previously described, there are some key major differences in the steps:

1. Because ringing or dialing requires participants, we need a list of `participants` to pass to the SDK.
2. Instead of using `joinCall`, which automatically pushes the state to `Joined`, you use `getOrCreateCall()` which will only create the call. You also pass in the participants and `ringing = true`. This will change the internal state to the `Outgoing` Call state, which will show the appropriate UI. You'll see that in a minute.
3. Like before, if something goes wrong, you show a message to the user.
4. Finally, after the API call, you reset the loading state.

If you think there's more to the implementation, there's really not. Our SDK was built with ease-of-use and simplicity in mind, allowing you to focus on what truly matters, like customizing the behavior or the UI of your apps.

Run the app on two devices or emulators and connect with two different users. Then on the Home screen, start a new call with ringing enabled and select the other user. You should see the Incoming and Outgoing UI. 

| HomeActivity                                                 | OutgoingCall Screen                                          | IncomingCall Screen                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![Home Screen Ringing](https://user-images.githubusercontent.com/17215808/216303437-2db9f9b6-823d-456b-999e-1b2124b11222.png) | ![Outgoing Call](https://user-images.githubusercontent.com/17215808/216303052-55ee4d71-04bb-4ddc-9c16-d517850b87b7.png) | ![Screenshot_1675335355](https://user-images.githubusercontent.com/17215808/216306313-8ea73cea-31e0-44c6-8be7-81bf13789cc8.png) |

Amazing work. With just a few lines of code you support Incoming and Outgoing Calls that are backed by the ringing Call type. Before that, you implemented meeting calls where people can join using the Call ID or deep links.

This covers the basic implementation of our SDK. But our SDK allows for deep customization of the UI and behavior. Let's see how to build custom Call layout based on the state.

## Customizing Call Layout

Our default Call layout features a very particular arrangement and behavior:

* If you are the only person in the call, you're shown as the only participant.
* If there are fewer than four participants, other participants are shown in a grid, but the local participant is shown as a floating item.
* If there are four or more participants, the local participant is shown as the last item in the grid and the UI lets you paginate through the rest of participants.

You can see that behavior in the following images.

| Single participant (Local)                                   | Two Participants (One Remote + Local)                        | Three Participants (Two Remote + Local)                      | Four or More Participants (Three or More Remote + Local)     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![Single Participant](https://user-images.githubusercontent.com/17215808/216321679-959b6523-2a15-4ced-9b00-61be17cffe3a.png) | ![Two Participants](https://user-images.githubusercontent.com/17215808/216321850-26426d3f-12e3-4c29-8966-ca94e121b5af.png) | ![Three Participants](https://user-images.githubusercontent.com/17215808/216321947-d7f60a1d-eb2b-4deb-a908-ecd244b78da5.png) | ![Untitled (2)](https://user-images.githubusercontent.com/17215808/216322097-3b60eb27-89c3-4d44-ac19-0930767c098f.png) |

However, you might want to customize this UI if your app use case is different.

For example, you might only want to customize or remove the header to conserve screen real estate. With Cideo Calls, the space is limited and you want to be able to see people and their feed clearly. That's why making the most of your space by removing unused or redundant items is a great option to have.

In other case, you might only support audio calls, so having video support isn't that important. In that case you can tweak the participant UI to show only avatars and you can customize how these avatars look. Additionally, you can remove some of the buttons at the bottom of the Call UI, which trigger actions for Video, like flipping the camera or enabling/disabling Video feed.

Let's customize the UI to try and build Audio only communication. Open `CallActivity.kt` and override the `buildContent()` function:

```kotlin
override fun buildContent(): @Composable () -> Unit {
    return {
        VideoTheme {
          // TODO - add custom UI
        }
    }
}
```

By providing a simple overrideable function that returns a `Composable`, you're able to render any content within the screen based on the call state. Within the `CallActivity` you have access to the `CallViewModel` for any state you might need to build custom UI.

Now add the following helper functions to the file:

```kotlin
@Composable
private fun CustomActiveCallContent() { // Whole custom UI in the active call state
    Scaffold(
        modifier = Modifier.fillMaxSize(),
        topBar = { CustomTopBar() },
        bottomBar = { AudioOnlyCallControls() },
        content = { AudioOnlyParticipants(paddingValues = it) }
    )
}

@Composable
private fun CustomTopBar() { // Top bar content
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .height(VideoTheme.dimens.topAppbarHeight)
            .background(color = VideoTheme.colors.barsBackground)
            .padding(VideoTheme.dimens.callAppBarPadding),
        verticalAlignment = Alignment.CenterVertically,
    ) {
        IconButton(
            onClick = ::handleBackPressed,
            modifier = Modifier.padding(
                start = VideoTheme.dimens.callAppBarLeadingContentSpacingStart,
                end = VideoTheme.dimens.callAppBarLeadingContentSpacingEnd
            )
        ) {
            Icon(
                painter = painterResource(id = R.drawable.ic_arrow_back),
                contentDescription = stringResource(id = R.string.back_button_content_description),
                tint = VideoTheme.colors.textHighEmphasis
            )
        }

        Text(
            modifier = Modifier
                .weight(1f)
                .padding(
                    start = VideoTheme.dimens.callAppBarCenterContentSpacingStart,
                    end = VideoTheme.dimens.callAppBarCenterContentSpacingEnd
                ),
            text = stringResource(id = R.string.default_app_bar_title),
            fontSize = VideoTheme.dimens.topAppbarTextSize,
            color = VideoTheme.colors.textHighEmphasis,
            textAlign = TextAlign.Start,
        )
    }
}

@Composable
private fun AudioOnlyParticipants(paddingValues: PaddingValues) { // Custom Participants UI to show up to two participants
    val callParticipants by callViewModel.participantList.collectAsState(initial = emptyList())
    val participantsToRender = callParticipants.take(2)

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(paddingValues)
    ) {
        participantsToRender.forEach {
            UserAvatarItem(
                modifier = Modifier
                    .fillMaxWidth()
                    .weight(1f),
                callParticipantState = it
            )
        }
    }
}

@Composable
private fun UserAvatarItem( // Participant item, which only shows an Avatar
    callParticipantState: CallParticipantState,
    modifier: Modifier = Modifier
) {
    UserAvatar(
        modifier = modifier.padding(16.dp),
        shape = RoundedCornerShape(16.dp),
        user = callParticipantState.toUser()
    )
}


@Composable
private fun AudioOnlyCallControls() { // Custom CallControls
    val callMediaState by callViewModel.callMediaState.collectAsState(initial = CallMediaState())

    val modifier = Modifier
        .fillMaxWidth()
        .height(VideoTheme.dimens.callControlsSheetHeight)

    val callControlsActions = buildDefaultCallControlActions(callMediaState = callMediaState)
        .filter {
            it.callAction !is FlipCamera && it.callAction !is ToggleCamera
        }

    CallControls(
        modifier = modifier,
        callMediaState = callMediaState,
        actions = callControlsActions,
        isScreenSharing = false,
        onCallAction = callViewModel::onCallAction
    )
}
```

There is quite a bit of code here, but it's very simple in what it does:

* `CustomActiveCallContent` is the main entry point, which will feature all of the UI you need in the Audio only use case.
* The `CustomTopBar` prepares a small header where you have the back `Button` and a simple `Text` element.
* `AudioOnlyParticipants` renders up to two participants in the Call. In this example we'll just serve 1:1 calls, but you can customize this to be more complex and feature many participants, not just two.
* `UserAvatarItem` represents each participant item in the UI.
* `AudioOnlyCallControls` is the customized set of actions the user can take, where you remove some of the default `CallControlAction`s.

Now that you have these functions prepared, you can plug them into the default content. The main part of our SDK is that you can choose which parts to override - you don't have to rebuild the whole UI yourself. Instead, you can replace just a specific _slot_ or part of the default behavior. To do so for the active Call content, add the following code to `buildContent()`:

```kotlin
override fun buildContent(): @Composable () -> Unit {
    return {
        VideoTheme {
            CallContent(
                modifier = Modifier.background(color = VideoTheme.colors.appBackground),
                viewModel = callViewModel,
                onCallAction = ::handleCallAction,
                onBackPressed = ::handleBackPressed,
                activeCallContent = { CustomActiveCallContent() } // here
            )
        }
    }
}
```

With just a single parameter that you pass in, you can replace only the active content. Build and run the app, ring another participant and join the call. You should see the following UI:

![Audio Only Call](https://user-images.githubusercontent.com/17215808/216340710-e96e311c-1fd1-4564-bbfe-2230ff213fa1.png)

You can see how you've simplified the UI, removed the unnecessary header information, call actions and similar. This is just a small piece of how powerful our SDK and its UI Components are. You can replace almost everything you can think of, while still keeping the internal state and business logic behavior the same.

This allows you to build rich and custom apps in less time than you would building everything yourself, or by using other third party providers. And the best part is, we support multiple programming paradigms, not just Kotlin and Jetpack Compose, but also the XML and View toolkit and Java.

## Further Integration

Congratulations on completing the Stream Video Android SDK tutorial. You've learned how to build two very popular use cases - Meeting and Ringing Calls. However, our SDK supports multiple other use cases and more advanced features. If you're looking to integrate more of our supported functionality, we recommend checking out the following guides:

* [Call Lifecycle](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/02-guides/02-call-lifecycle.mdx): It's important to understand the lifecycle of our SDK and Calls to properly build complex use cases for your users.
* [Call Engine](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/02-guides/03-call-engine.mdx): If you're looking to utilize our state machine to the fullest, explore what our internal CallEngine does and how to listen to state.
* [Deep linking](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/05-advanced/01-deeplinking.mdx): Deep linking is very useful for Meeting apps where you can simply send a link for the Call that lets people join.
* [Push Notifications](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/05-advanced/02-push-notifications.mdx): Apps where Ring people and invite them to Calls heavily rely on push notifications. Learn how to integrate them with our SDK.

Alternatively, if you're modeling your app based on popular apps, like Messenger, Telegram, Zoom, Google Meet, Twitter Spaces or Twitch, we have several guides and template projects prepared for you:

* [Chat + Video](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/02-guides/06-chat-with-video.mdx): Messenger and Telegram like applications feature Chat as a primary source of communication, with Video being secondary. To build a similar app, folllow our Chat + Video guide that provides you with a template project to kick start your app, with all the UI and setup pre-baked.
* [Video + Chat](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/02-guides/07-video-with-chat.mdx): If you're building a Meeting based app, like Zoom or Google Meet, then the Video + Chat guide is for you. It provides you with a template project that pre-bakes all the UI and SDK setup, so you can focus on what matters.
* [Audio Rooms](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/02-guides/08-audio-rooms.mdx): Some apps feature live audio rooms where people gather to discuss ideas and fun topics. Apps like Twitter Spaces are popular and you can build them using our Audio Rooms guide. It also prepares a template project for you that cuts the time you need to start working on your app.
* [Livestream](https://github.com/GetStream/stream-video-android/blob/docs/structure-improvement/docusaurus/docs/Android/02-guides/09-livestream.mdx): Last, but not least, our Livestream guide teaches you how to build an app where one person streams their tracks to a group of people in real time. By the end of the guide, you'll have a project that prepares most of the setup for you.
