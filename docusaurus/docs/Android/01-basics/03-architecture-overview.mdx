## Architecture Overview

As you've learned in the [SDK introduction](02-introduction.mdx), the Stream SDK consists of different artifacts:

* **Low-level client (LLC)**
* UI Components (Compose and XML)
* Push Provider(s)

No matter which parts of our SDK you choose to use, you'll rely on the **low-level client** to set up a connection to our API and handle calls. And it's good to understand the architecture under the hood that powers our API.

Let's dive into the LLC and ways of initializing various components it provides.

## Low-Level Client

The LLC consists of three main constructs that let you easily query and join calls:

+ **StreamVideo**: The main client that you initialize with a user presence. It lets you create, look up and join calls, as well as create the `CallClient`. 
+ **CallClient**: Call-specific client that you initialize when joining a call. It exposes various handles for audio and video devices, muting and unmuting, listening to call specific events and observing the call state. 
+ **CallViewModel**: Higher level wrapper around `StreamVideo` and `CallClient`, that lets you easily control all the state and functionality in a call. It also exposes various pieces of state that lets you render your video call UI.

Using each of these lets you access different functionality that helps you build video calling features. Check out each of the respective pages to learn more details about each component:

* [StreamVideo](../02-client/02-stream-video.mdx)
* [CallClient](../02-client/03-call-client.mdx)
* [CallViewModel](../02-client/04-call-view-model.mdx)



### CallClient

Once the user joins a call through `StreamVideo` and its `joinCall` and similar functions, you'll receive a `JoinedCall`. It contains several pieces of information required to create a `CallClient` and fully connect to a `Call`.

You can create the client like so:

```kotlin
val callClient = streamVideo.createCallClient(
    input.callUrl,
    input.userToken,
    input.iceServers,
    credentialsProvider
)
```

You have to pass in a few parameters:

* `signalUrl`: Also known as the call URL, this describes the server where the call is happening.
* `userToken`: The token that authenticates the user against the aforementioned server.
* `iceServers`: List of servers used to fetch and connect to audio and video tracks.
* `credentialsProvider`: The provider that holds user-based information. 

You should create the `CallClient` as soon as you join a call through `StreamVideo`, or as soon as your users are ready to fully connect, based on your use case.

You can either create the client yourself or through our `CallViewModel`. Let's see how it works.

### CallViewModel

The `CallViewModel` lets you automate most of the call features and flow, by delegating the call responsibilities to us. We've prepared a set of functionality and API that lets you control audio and video devices, the initialization of the call, listening to events and more.

To create the `ViewModel`, you can use its factory:

```kotlin
private val factory by lazy {
    CallViewModelFactory(callInput, streamVideo, credentialsProvider)
}

private val callViewModel by viewModels<CallViewModel>(factoryProducer = { factory })
```

You're already familiar with `StreamVideo` and `CredentialsProvider`. The last notable parameter of the `CallViewModelFactory` is the `callInput`.

It's a small data structure that contains the aforementioned parameters, as well as a few other ones:

```kotlin
public data class CallInput(
    val callCid: String,
    val callType: String,
    val callId: String,
    val callUrl: String,
    val userToken: String,
    val iceServers: List<IceServer>,
) : java.io.Serializable
```

* `callCid`: The combination of the `callId` and `callType`.
* `callType`: The type of call.
* `callId`: Unique identifier of the call for a given type.

You can construct this with the data you get from joining a call. You should create the `CallViewModel` if you want to simplify things when connecting to calls, and you can do it right before connecting to the call and creating the `CallClient`. The `ViewModel` does this internally.

## Exploring the Call Lifecycle

These components have different scopes of life, so if you want to learn more about creating and disposing of such constructs, read more in our [call lifecycle](../04-guides/01-call-lifecycle.mdx) guide.
