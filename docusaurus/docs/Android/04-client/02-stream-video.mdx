## StreamVideo

This is the main part of our SDK and it needs to be initialized with a user and a token. We require this as it doesn't make much sense to start our client without the user present.

To initialize it, you can do the following:

```kotlin
val credentialsProvider = AuthCredentialsProvider(
    apiKey = "<your-api-key>",
    userToken = token, // the token from the BE
    user = user // the User object with extra information
)

val streamVideo = StreamVideoBuilder(
    context = this,
    credentialsProvider = credentialsProvider,
    loggingLevel = LoggingLevel.BODY, // we support
).build()
```

By creating a `CredentialsProvider` and passing it down to the `StreamVideoBuilder` you're able to `build()` the instance that lets you connect to our API.

There are a few other parameters and items that are important here:

* `apiKey`: This serves as the main key to your Stream environment.
* `userToken`: The token you get by authenticating your users for our backend.
* `user`: The user object that contains information about their ID, name, profile image and more...
* `loggingLevel`: The amount of information you want logged from all the underlying API calls.

Once you create `StreamVideo`, it also creates a WebSocket connection that listens to different events from the server. If you want to learn more about it, read through our [socket events guide](../04-guides/03-socket-events.mdx).

## Functionality

`StreamVideo` exposes a few groups of functionality that you can use to build your use case:

* Call CRUD operations
* Event handling
* Call State & Management

All of these functions are exposed within `StreamVideo`, but it's easier to explore them in an intuitive way. Let's see what each group allows you to do.

### Call Crud operations

You can find the following functions within the CRUD group:

```kotlin
public suspend fun createCall(
    type: String,
    id: String,
    participantIds: List<String> = emptyList(),
    ringing: Boolean
): Result<CallMetadata>

public suspend fun getOrCreateCall(
    type: String,
    id: String,
    participantIds: List<String> = emptyList(),
    ringing: Boolean
): Result<CallMetadata>

public suspend fun createAndJoinCall(
    type: String,
    id: String,
    participantIds: List<String>,
    ringing: Boolean
): Result<JoinedCall>

public suspend fun joinCall(type: String, id: String): Result<JoinedCall>

public suspend fun joinCall(call: CallMetadata): Result<JoinedCall>
```

They should be fairly self-explanatory, but here's a rundown:

* `createCall`: Allows you to create new calls with a given `type` and `id`. You can also pre-set a list of participants and ring them if necessary. It returns a `CallMetadata` result, which you can use to join the call.

  > **Note**: If a call with the same combination of `type` and `id` already exists, this will return an error. 

* `getOrCreateCall`: More advanced version of `createCall`, which gets an existing call if it already exists, instead of returning an error.

* `joinCall`: There are two variants of this function, which let you join a call with the supplied information. Returns a `JoinedCall` with the data required to create a `CallClient` and connect to it.

* `createAndJoinCall`: Combines the operations of `getOrCreateCall` and `joinCall` for ease-of-use.

  > TODO - double check naming

### Event Handling

If you're interested in listening to events that we provide through the underlying WebSocket, as well as sending events yourself, you can use the following API:

```kotlin
public fun addSocketListener(socketListener: SocketListener)

public fun removeSocketListener(socketListener: SocketListener)

public suspend fun sendEvent(
    callCid: String,
    eventType: CallEventType
): Result<Boolean>

public suspend fun sendCustomEvent(
    callCid: String,
    dataJson: String
): Result<Boolean>

public suspend fun acceptCall(type: String, id: String): Result<JoinedCall>

public suspend fun rejectCall(cid: String): Result<Boolean>

public suspend fun cancelCall(cid: String): Result<Boolean>
```

* `addSocketListener`: Adds and hooks up a listener for the underlying WebSocket. Lets you receive and react to every event the socket processes.
* `removeSocketListener`: Allows you to remove a listener instance to free up memory and stop receiving events.
* `sendEvent`: Lets you send different `CallEventType`s to the server to note user response to a Call.
* `sendCustomEvent`: Lets you send custom data events to the server.
* `acceptCall`, `rejectCall` and `cancelCall`: Specific ease-of-use implementations of `sendEvent`.

The final group of functionality is related to active calls.

### Call State & Management

Once you set up a call either by creating a new one or joining an existing, you can access and manage its state through `StreamVideo`:

```kotlin
public val callState: StateFlow<StreamCallState>

public fun clearCallState()

public fun getUser(): User

public fun createCallClient(
    signalUrl: String,
    userToken: String,
    iceServers: List<IceServer>,
    credentialsProvider: CredentialsProvider
): CallClient

public fun getActiveCallClient(): CallClient?
```

* `callState`: An easy accessor to our call engine that produces the `StreamCallState`. If you want to learn more about this, check out our [call-engine-state guide](../02-guides/03-call-engine-state.mdx).
* `clearCallState`: Allows you to clear up all the state related to an active call, in turn shutting down the call and stopping any tracks for the user.
* `getUser`: Accessor for the user state.
* `createCallClient`: Used to create the `CallClient` that handles the call and lets you publish tracks. Learn more about it in the [CallClient overview](03-call-client.mdx).
* `getActiveCallClient`: Returns the active instance of the `CallClient` if it exists and a call is running. Otherwise returns `null`.