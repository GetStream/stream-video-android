---
title: ViewModel & Activity
description: How to use the CallViewModel and AbstractCallActivity
---

We include a `CallViewModel` & `AbstractCallActivity`, which are extendable and help you to build the [picture-in-picture mode](https://developer.android.com/develop/ui/views/picture-in-picture) quickly.

### CallViewModel

The call viewModel is a light wrapper around states of the PIP mode.

In the example below you see how to create a call view model in an activity:

```kotlin
// create a CallViewModel
val factory by lazy { CallViewModelFactory() }
val vm by viewModels<CallViewModel> { factory }
```

Creating a `CallViewModel` in compose is a bit easier:

```kotlin
@HiltViewModel
class MyCallViewModel @Inject constructor(): CallViewModel() {
  ..
}

@Composable
private fun MyCallContainer(
    call: Call,
    myCallViewModel: MyCallViewModel = hiltViewModel()
) {
    CallContainer(
        modifier = Modifier.background(color = VideoTheme.colors.appBackground),
        call = call,
        callViewModel = myCallViewModel,
    )
}
```

As you can see the above example, you can extend the `CallViewModel` to your own ViewModel and create the instance with [Hilt](https://developer.android.com/jetpack/compose/libraries#hilt).

The ViewModel exposes the following fields:

| Attribute | Description |
| --- | --- |
| `isInPictureInPicture` | If picture in picture is active |

Typically, we recommend that you build your own ViewModel and use the included `callViewModel` as inspiration.

### AbstractCallActivity

If you subclass the `AbstractCallActivity`, you get several things out of the box:

* FullScreen support
* Picture in picture support
* setShowWhenLocked

This example shows how to use the `AbstractCallActivity`:

```kotlin
class MainActivity : AbstractCallActivity() {

    // ensure that you override this method.
    override fun provideCall(): Call {

        // you must initialize `StreamVideo` somewhere before using this `instance()` method.
        val streamVideo = StreamVideo.instance()
        return streamVideo.call(type = "default", id = callId)
    }

    // create a CallViewModel.
    private val factory by lazy { CallViewModelFactory() }
    private val vm by viewModels<CallViewModel> { factory }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // join a call, which type is `default` and id is `123`.
        lifecycleScope.launch {
            call.join(create = true)
        }

        setContent {
            VideoTheme {
                // render videos
                CallContainer(
                    modifier = Modifier.fillMaxSize(),
                    call = call,
                    callViewModel = vm,
                    onBackPressed = { handleBackPressed() },
                    onCallAction = { callAction ->
                        when (callAction) {
                            is FlipCamera -> call.camera.flip()
                            is ToggleCamera -> call.camera.setEnabled(callAction.isEnabled)
                            is ToggleMicrophone -> call.microphone.setEnabled(callAction.isEnabled)
                            is LeaveCall -> finish()
                            else -> Unit
                        }
                    }
                )
            }
        }
    }

    // ensure that you override this method.
    override fun pipChanged(isInPip: Boolean) {
        super.pipChanged(isInPip)
        vm.onPictureInPictureModeChanged(isInPip)
    }
}
```

:::note
Make sure that you override the `provideCall` and `pipChanged` methods.
:::

The following methods on the call activity are available:

| Attribute | Description |
| --- | --- |
| `call` | The call object that you've created inside the `provideCall` method |
| `toggleFullscreen` | Toggle the fullscreen mode |
| `setFullscreen` | Enable fullscreen |
| `exitFullscreen` | Exit fullscreen |
| `showWhenLockedAndTurnScreenOn` | Release a screen lock and turn on the display |


